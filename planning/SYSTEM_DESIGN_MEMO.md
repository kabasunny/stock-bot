# システム設計に関する検討事項

## 本ドキュメントの歩き方と運用ルール

本ドキュメントは、プロジェクトの全体像、現在のアーキテクチャ、主要な決定事項、未解決の課題、開発標準手順、そして直近の進捗と次のアクションプランを示す「要約」です。この「要約」は、常に**シンプルかつ明確**であることを最優先し、過度な詳細や冗長な記述を避けることを原則とします。

過去の詳細な開発経緯やデバッグの記録は、**`@planning/DEVELOPMENT_LOG.md`** に時系列で記載されています。

### 作業開始時の確認フロー

1.  **最初にここを見る**:
    まず、このファイル (`SYSTEM_DESIGN_MEMO.md`) の **`次回のアクションプラン`** セクションを確認してください。これが現在の最優先タスクリストです。
2.  **背景を理解する**:
    アクションプランの背景を理解するために、同ファイルの **`実装から得られた知見`** を確認します。最新の開発進捗については `DEVELOPMENT_LOG.md` の先頭を参照してください。
3.  **過去に遡る**:
    さらに詳細な経緯や過去の意思決定について知りたい場合は、**`@planning/DEVELOPMENT_LOG.md`** を参照してください。

### 開発進捗（Progress）の記録ルール (最優先事項)

本ドキュメントにおける「開発進捗」の記述は、以下の原則に厳密に従います。

*   **簡潔性**: 完了したタスクの概要と、その結果がプロジェクト全体にどのような影響を与えたか（例: 「〜により、動的な取引が可能になった」）を**戦略的レベルで簡潔に**記述します。
*   **高レベルの記述**: 実装の詳細、試行錯誤の過程、具体的なコードスニペット、APIレスポンスの断片などは一切含めません。これらはすべて後述の「詳細な記録」に記載します。
*   **更新タイミング**: 「次回のアクションプラン」に記載されたタスクが完了するたびに更新します。

### `次回のアクションプラン（Next Action Plan）` の運用 (最優先事項)

このセクションには、現在取り組むべき最優先タスクのみを、その「目的」と「具体的な作業内容」を明確にして記述します。冗長な記述は避け、常に実行可能なタスクとして提示します。

### `詳細な記録（Detailed Log）` の運用 (最優先事項)

すべての技術的な詳細、コード変更の理由、デバッグの経緯、発見された問題とその解決策、APIとのやり取りの具体例などは、**`@planning/DEVELOPMENT_LOG.md`** に時系列で記録します。このファイルはプロジェクトの「活動履歴」であり、いかなる詳細も許容されます。

### `専門ドキュメント（Specialized Documents）` の活用 (最優先事項)

特定の大きな設計タスク、深い技術調査、複雑なリファクタリング計画など、自己完結した内容については、`planning/` ディレクトリ内に新たな専用のマークダウンファイル（例: `PERFORMANCE_ANALYTICS_DESIGN.md`）を作成します。これにより、単一のドキュメントが肥大化するのを防ぎ、関連情報の検索性を高めます。

### 「実装から得られた知見」セクションの運用 (変更なし)

このセクションは、開発中に得られた重要なノウハウやAPIの仕様など、**現在頻繁に参照する必要がある知見**を記録する場所です。

*   **定期的な見直し**: プロジェクトのフェーズが進むにつれて、一部の知見は「当たり前のこと」になったり、参照頻度が低下したりします。陳腐化した情報や詳細すぎる情報は、定期的に **`@planning/DEVELOPMENT_LOG.md`** に移動させます。
*   **要約を心がける**: 新しい知見を追記する際は、結論と要点を簡潔に記述します。詳細な経緯や試行錯誤の記録は、`@planning/DEVELOPMENT_LOG.md` に記載します。

このルールにより、`SYSTEM_DESIGN_MEMO.md` は常に最新かつ重要な情報へのクイックリファレンスとして機能します。
---

## 1. はじめに

本ドキュメントは、株式自動取引システムのアーキテクチャを具体化するにあたり、検討すべき主要な論点を整理することを目的とします。
*(2025-12-06 追記: 当初の設計から議論を経て、より責務が明確な「エージェント中心」のアーキテクチャへと方針を更新した。以降の章は、この新しい方針を反映している。)*

## 2. 基本アーキテクチャ方針 (エージェント中心モデル)
システムは、責務が明確に分離された以下の3つのコンポーネントで構成される。

1.  **Go製 APIラッパー (Go API Wrapper)**
    -   **役割**: 証券会社APIとの直接的な通信（REST, WebSocket）をすべて担当し、その複雑さを抽象化する。
    -   **機能**: 外部からのHTTPリクエストに基づき、データ取得、注文執行などを行う。Goaフレームワークを用いて、堅牢なHTTP APIを公開する。
    -   https://github.com/e-shiten-jp?tab=repositories ここに参考のPythonコードがあるので、リクエストを作成する際の参考にする

2.  **Python製 シグナル生成サービス (Python Signal Generator)**
    -   **役割**: 高度な計算や機械学習モデルを用いて、売買シグナルを生成することに特化する。
    -   **機能**: 外部から市場データを受け取り、分析結果のシグナルを返すHTTP APIを公開する。自らは動かない受動的なコンポーネント。

3.  **エージェント (Agent)**
    -   **役割**: システム全体の「頭脳」であり、主体的な意思決定を行う中央司令塔。
    -   **機能**: 取引戦略のメインループとして、Go APIラッパー（データ取得/注文）とPythonサービス（シグナル問合せ）を呼び出し、全体のワークフローを指揮する。

## 3. 主要なワークフロー
すべてのワークフローは「エージェント」が起点となる。

1.  **エージェント**: データ取得のため **Go APIラッパー** を呼び出す。
2.  **Go APIラッパー**: 証券会社APIからデータを取得し、エージェントに返却する。
3.  **エージェント**: 受け取ったデータを **Pythonサービス** に渡し、売買シグナルを問い合わせる。
4.  **Pythonサービス**: データ分析を行い、シグナルをエージェントに返却する。
5.  **エージェント**: シグナルと自身のロジックに基づき売買を判断し、**Go APIラッパー** を呼び出して発注を指示する。

## 4. 実装計画と技術選択

### 4.1. 短期計画: Goによるモノリシックな実装
まず、迅速にプロトタイプを構築するため、**Go APIラッパー**と**エージェント**を単一のGoアプリケーション内のコンポーネントとして実装する。
- コンポーネント間の通信は、Goaで定義したHTTP APIを通じて行う (`localhost`経由)。これは将来的なサービス分割（次項）を見据えた疎結合な設計のためである。

### 4.2. 長期目標: エージェントのRust化
システムの安定稼働後、さらなるパフォーマンスと安全性を追求するため、**エージェントをRust製のマイクロサービスとして再実装し、独立させる**ことを最終目標とする。
- 初期段階で通信をHTTP APIに定めているため、Go製エージェNTをRust製エージェントに置き換える作業は、比較的スムーズに行える。

## 5. 実装に向けた主要な検討事項 (Issue)
*(このセクションは、新しいアーキテクチャの観点から再構成)*

### Issue 1: リアルタイムイベントの受信方式の特定 (変更なし)
-   **論点**: 利用する証券会社APIは、リアルタイムの株価情報や約定通知などをどのような形式で提供しているか？ (WebSocket, etc.)
-   **重要性**: Go APIラッパーの`EventClient`の実装方法に大きく影響する。

### Issue 2: コンポーネント間連携インターフェース設計 (更新)
-   **論点**: エージェント、Go APIラッパー、PythonサービスはそれぞれHTTP APIを介して通信する。Go APIラッパーのAPI設計にはGoaフレームワークを採用する。
-   **データ形式**: 連携時のデータ形式はJSONとする。

*(旧Issue 3, 4は新アーキテクチャにおいて責務が明確化されたため解消)*

---

### 開発標準手順

### リファクタリング標準手順 (2025-12-09 追記)
レイヤー間の責務移動など、アーキテクチャの健全性を維持するためのリファクタリングは、以下の手順書に従って実施する。
- **`planning/REFACTORING_PROCEDURE.md`**

### 共通操作におけるユーザーとの連携方針

プロジェクトのビルド、アプリケーションサーバーの起動、および `curl` コマンドなどによるAPIエンドポイントのテストといった、システムの状態を変更したり、外部との連携を伴う共通操作については、以下の原則に基づきユーザーに実行を依頼する。

-   **ビルド操作**: `go build` 等のビルドコマンド。
-   **アプリケーションサーバーの起動**: `go run` やコンパイル済みバイナリの実行など。
-   **外部連携コマンド**: `curl`, `Invoke-WebRequest` など、APIエンドポイントへのリクエスト送信。

これは、ユーザー環境への影響を最小限に抑え、各ステップにおいてユーザーの明示的な承認を得るためのものである。

### Goaサービス実装の標準手順 (2025-12-07 追記)

GoaでAPIサービスを実装する際の標準的な手順を以下に定める。これは、テスト駆動開発(TDD)のアプローチを取り入れ、堅牢なシステム構築を目指すものである。すべてのGoaサービス実装において、この手順に統一して開発を進めること。

**ゴール**: 特定のAPIエンドポイントが、クライアントから受け取った情報に基づき、インフラ層のクライアントを呼び出し、必要な処理を実行して、その結果を返す。

**前提**: Goaの設計ファイル (`design/design.go`) にAPI定義が完了しており、`goa gen` によってコードが自動生成されていること。また、インフラ層の外部APIクライアントは単体テストが完了していること。

#### ステップ1: ユースケースの「振る舞い」をテストで定義する (TDD)
目的: `UseCase` が持つべき振る舞いをテストで定義する。

1.  **テストファイル作成**: `internal/app/<service_name>_usecase_impl_test.go` を新規作成。
2.  **テスト内容**:
    *   モック（例: `OrderRepository`, `TachibanaOrderClient`）を準備し、`UseCase` が依存するコンポーネントが期待通りに呼び出されることを検証する。
    *   成功ケース、失敗ケース、バリデーションエラーなど、主要なシナリオに対するテストケースを記述する。
3.  **実行**: `go test ./internal/app/...` を実行。テストはコンパイルエラーまたは失敗するはず。これが、次の実装の明確なゴールとなる。

#### ステップ2: テストをパスさせるユースケースを実装する
目的: ステップ1で書いたテストをパスさせる。

1.  **実装ファイル作成**: `internal/app/<service_name>_usecase_impl.go` を新規作成。
2.  **実装内容**:
    *   `<Service>UseCaseImpl` 構造体を定義し、依存する `Repository` や `Client` をフィールドに持つ。
    *   `Execute<Service>` メソッド（または対応するメソッド）を実装する。この中で、インフラ層のクライアントを呼び出し、ビジネスロジックを実行する。
3.  **実行**: `go test ./internal/app/...` を実行し、**ステップ1のテストがすべてパスする**まで実装を修正する。

#### ステップ3: アプリケーション起動時の依存性注入 (DI)
目的: アプリケーション起動時に、各コンポーネントを正しく組み立てる。

1.  **ファイル修正**: `cmd/myapp/main.go` を修正。
2.  **実装内容**:
    *   インフラ層のクライアント、リポジトリのインスタンスを作成。
    *   上記を `New<Service>UseCaseImpl` に渡して `UseCase` のインスタンスを作成。
    *   作成した `UseCase` を `web.New<Service>Service` に渡して `Service` (ハンドラ) のインスタンスを作成。
    *   Goaサーバーに `Service` を登録する。
3.  **実行**: `go run ./cmd/myapp/main.go` を実行し、コンパイルエラーや起動時エラーが出ないことを確認する。

#### ステップ4: ハンドラとユースケースのつなぎこみ
目的: APIハンドラから、DIされたユースケースを呼び出す。

1.  **ファイル修正**: `internal/handler/web/<service_name>_service.go` を修正。
2.  **実装内容**:
    *   Goaの `Payload` を `app.Params` に変換する。
    *   `s.usecase.Execute<Service>(...)` を呼び出す。
    *   結果をGoaの `Result` に変換して返す。

#### ステップ5: 統合テスト
目的: APIエンドポイントを実際に呼び出し、システム全体が正しく連携して動作することを確認する。

1.  **実行**:
    1.  `go run ./cmd/myapp/main.go` でサーバーを起動。
    2.  `curl` などのツールで対象のAPIエンドポイントを呼び出す。
2.  **確認**:
    *   期待通りのHTTPステータスコードとレスポンスボディが返ってくること。
    *   (必要に応じて) データベースや外部システムのログなどで、処理が正しく行われたことを確認する。



Invoke-WebRequest -Uri http://localhost:8080/order -Method POST  -Headers @{"Content-Type"="application/json"} -Body '{"symbol":"6658","trade_type":"BUY","order_type":"MARKET","quantity":100}'

---



## 開発進捗（2025-12-22）

### 価格情報取得サービス (`price`) の実装と環境構築
-   **Goaサービス定義の追加とコード生成**:
    -   `design/design.go` に `price` サービス（`GET /price/{symbol}`）と `StockbotPrice` 型を定義しました。
    -   `goa gen stock-bot/design` コマンドを実行し、`price` サービスに対応するGoaクライアント、サーバー、ユースケースのボイラープレートコードを自動生成しました。
-   **`price` ユースケースの実装とテスト**:
    -   `internal/app/price_usecase.go` で `PriceUseCase` インターフェースを定義しました。
    -   `mockery` をインストールし、`internal/infrastructure/client/PriceInfoClient` のモックを生成しました。
    -   `internal/app/price_usecase_impl_test.go` で `PriceUseCase` のテスト（成功ケース、複数のエラーケース）を定義し、パスすることを確認しました。
    -   `internal/app/price_usecase_impl.go` で `PriceUseCaseImpl` を実装し、全てのテストがパスすることを確認しました。実装には、`PriceInfoClient` からのデータ取得、文字列からfloat64への変換、エラーハンドリングを含みます。
-   **Goaハンドラの実装**:
    -   `internal/handler/web/price_service.go` でGoaハンドラ `PriceService` を実装し、`PriceUseCase` を呼び出すようにしました。
-   **アプリケーション起動時の依存性注入 (DI)**:
    -   `cmd/myapp/main.go` を修正し、`price` サービス関連の依存性注入（`PriceUseCase`、`web.PriceService` の初期化とGoaサーバーへのマウント）を組み込みました。
-   **環境セットアップ**:
    -   `docker compose up -d` コマンドでデータベースコンテナを含むDocker環境を起動しました。
    -   `go run ./cmd/migrator/main.go` でデータベースのマイグレーションを正常に適用しました。
    -   `go run ./cmd/myapp/main.go` でアプリケーションがコンパイルエラーなく起動することを確認しました（ユーザーによるキャンセル）。

---

## 開発進捗（2025-12-23）

### 注文リクエスト生成ロジックの実装とログ強化
-   **注文リクエスト生成ロジック**: `agent.go`の`tick`メソッド内で、シグナルと内部状態（ポジション、残高）に基づいた`PlaceOrderRequest`の生成ロジック（注文数量の決定、成行注文固定など）が既に実装されていることを確認し、本タスクを完了としました。
-   **ログ強化**: `agent.go`の`tick`メソッドに、現在のポジションと注文の詳細をログ出力する機能を追加し、エージェントの内部状態の可視性を向上させました。

### シグナルファイル選択ロジックの改善
-   **FindSignalFile関数の強化**: `agent.go`の`FindSignalFile`関数を修正し、`signalPattern`に一致する複数のシグナルファイルが見つかった場合、最も更新日時が新しいファイルを優先的に選択するようにロジックを強化しました。これにより、エージェントが常に最新のシグナルに基づいて意思決定を行えるようになります。
-   **ユニットテストの追加**: `agent_test.go`に`FindSignalFile`関数の改善されたロジック（特に更新日時による選択）を検証するユニットテストを追加し、修正された関数の動作が意図通りであることを保証しました。

### エージェントのコンテキスト管理最適化
-   **tickメソッドにおけるコンテキストの最適化**: `agent.go`の`tick`メソッド内で`PlaceOrder`呼び出しに使用されている`context.WithTimeout`を、ループの外で一度生成し、それを各シグナルの処理に渡すように変更しました。これにより、ループ内での不必要なコンテキストの生成と破棄を避け、リソースの消費を抑え、コードの効率性を向上させました。

### 動的ポジションサイジングロジックの実装（第一段階）
-   **目的**: 固定ロット数による注文を、口座の資金状況とリスク許容度を考慮した動的な数量決定ロジックに置き換え、エージェントの取引判断をより実践的にしました。
-   **実装**:
    -   `agent_config.yaml`に`trade_risk_percentage`と`unit_size`を追加しました。
    -   `TradeService`インターフェースを拡張し、`price`サービスを呼び出す`GetPrice`メソッドを実装しました。
    -   `agent.go`の`tick`メソッド内で、買付余力と現在価格、設定ファイルのリスク許容度に基づき、動的に注文数量を計算するロジックを実装しました。

### `GoaTradeService.PlaceOrder` の実装と注文の永続化
-   **目的**: エージェントが発行する注文を実際に証券会社APIに送信し、その注文情報をデータベースに永続化する仕組みを構築しました。
-   **実装**:
    -   `goa_trade_service.go`の`PlaceOrder`メソッドを実装し、実際のAPI呼び出しとDB保存を行うようにしました。
    -   注文に必要な第二パスワードを`config`から読み込むように修正し、`orderRepo`を`GoaTradeService`に注入しました。

---

#### 次回のアクションプラン
(現在、特定の最優先タスクはありません。次のアクションプランを検討してください。)

---

## 開発進捗（2025-12-20）

### ログイン仕様のテストと明確化
APIのログイン仕様に関する不明点を解消するため、`planning/LOGIN_TEST_PLAN.md`を作成し、体系的なテスト計画を立案した。
`TEST-001`（連続ログイン）および`TEST-002`（時間差ログイン）を実行し、以下の重要な仕様を特定した。

1.  **電話認証の有効期間**: 手動での電話認証後、実際にログインリクエストが成功するまでの有効期間は**約3分**であることを確認した。
2.  **セッションの独立性**: ログインに成功するたびに、サーバーは新しい独立したセッションを確立する。

### APIクライアントのリファクタリング: セッションオブジェクトの導入
上記テスト結果と、より高度なセッションテストの必要性から、クライアントからセッション状態を分離する大規模なリファクタリングを実施した。

**本日完了した作業:**
*   **`Session`構造体の定義**: ログイン情報をカプセル化する`Session`構造体を`session.go`に作成。
*   **クライアントのステートレス化**: `TachibanaClientImpl`からセッション状態（ログイン情報、p_no等）を削除し、`sUserId`, `sPassword`などログインに必要な初期設定のみを残すように修正。
*   **インターフェースの更新**: `AuthClient`, `PriceInfoClient`, `OrderClient`, `BalanceClient`, `MasterDataClient`の全メソッドのシグネチャを、`Session`オブジェクトを利用する形に更新。
*   **実装の更新**: 上記インターフェース変更に伴い、`DownloadMasterData`を除く全ての`...ClientImpl`の実装を修正。

### 複数のセッション独立性に関するテスト結果 (2025-12-20 追加)
`auth_client_impl_test.go` に追加した `TestAuthClientImpl_MultipleSessions` の結果、以下のAPI仕様が判明しました。
*   **新しいログインセッションが確立されると、それ以前のセッションはサーバー側で無効化される。**
*   複数のログインセッションを同時にアクティブな状態に保ち、それぞれを独立して操作（ログアウトなど）することはできません。常に最新のセッションのみが有効です。

### APIクライアントのリファクタリングに伴うテストコードの全面的な修正 (2025-12-20 更新)
`APIクライアントのリファクタリング: セッションオブジェクトの導入` に伴い、以下のテストコードを修正しました。

**修正済みテストファイル:**
*   `internal/infrastructure/client/tests/order_client_impl_neworder_test.go`
*   `internal/infrastructure/client/tests/order_client_impl_cancelorder_test.go`
*   `internal/infrastructure/client/tests/order_client_impl_correctorder_test.go`
*   `internal/infrastructure/client/tests/order_client_impl_cancelorderall_test.go`
*   `internal/infrastructure/client/tests/order_client_impl_getorderlist_test.go`
*   `internal/infrastructure/client/tests/order_client_impl_getorderlistdetail_test.go`
*   `internal/infrastructure/client/tests/master_data_client_impl_test.go` (GetMasterDataQuery, GetNewsHeader, GetNewsBody, GetIssueDetail, GetMarginInfo, GetCreditInfo, GetMarginPremiumInfo)
*   `internal/infrastructure/client/tests/master_data_client_impl_download_masterdata_test.go`
*   `internal/infrastructure/client/tests/event_client_impl_test.go`
*   `internal/infrastructure/client/tests/price_info_client_impl_demo_test.go`

### ログイン仕様に関するテスト結果 (2025-12-20 追加)
`planning/LOGIN_TEST_PLAN.md` に基づき、ログイン関連のテストを実施しました。
*   **TEST-003: ログアウト後の再ログイン**: ログイン、ログアウト、直後の再ログインがすべて成功。これにより、電話認証の有効期間内であれば、ログアウト後すぐに再ログインが可能であることが確認されました。
*   **TEST-004: タイムラグを伴ったログアウト後の再ログイン**: 
    *   `auth_client_impl_test.go` に `TestAuthClientImpl_Sequence_LoginWaitLogoutLogin` を実装し、「ログイン → 5分待機 → ログアウト → 再ログイン」のシーケンスを単一のテストとして自動化しました。
    *   実行結果、初回ログインとログアウトは成功しましたが、5分経過後の再ログインは `result code 10089` （電話認証の有効期間切れ）で失敗しました。
    *   この結果から、電話認証の有効期間（3分）は再ログインの可否に強く影響するが、一度確立されたセッションのログアウトは時間経過後も可能であることが判明しました。
*   **TEST-006: セッションの競合（二重ログイン）**: `auth_client_impl_test.go` に `TestAuthClientImpl_MultipleSessions` を実装し、複数のログインセッションの独立性を確認しました。結果、新しいログインが確立されると、それ以前のセッションはサーバー側で無効化されることが判明しました。常に最新のセッションのみが有効であるという前提でセッション管理を行う必要があります。

### TEST-005 無通信タイムアウトテストの準備状況 (2025-12-20 追加)
`TEST-005: 無通信タイムアウトの確認` のため、`price_info_client_impl_prod_test.go` に実装済みの `TestPriceInfo_Sequence_LoginWaitGetPrice` を実行する段階です。このテストは30分間の自動待機を含むため、コマンド実行後は手動監視なしで完了を待つことができます。

### APIクライアントリファクタリングの完了 (2025-12-20 追加)
`Session`オブジェクトの導入に伴うリファクタリングの最終作業として、`UseCase`層および`Handler`層の修正を完了し、ビルドが成功することを確認しました。

*   **`UseCase`層の修正**: `balance`, `position`, `order`, `master` の各`UseCase`のインターフェースと実装を更新し、クライアントAPIを呼び出すメソッドが`Session`オブジェクトを引数として受け取るように変更しました。
*   **`Handler`層の修正**: Goaで実装された各サービス（ハンドラ）が、起動時にDIされた`Session`オブジェクトを保持し、`UseCase`の呼び出し時に渡すように修正しました。
*   **`UseCase`テストの修正**: `internal/app/tests`内の各テストコードを修正し、`Session`オブジェクトの変更に対応させました。
*   **`main.go`の修正**: アプリケーション起動時に`LoginWithPost`で`Session`を生成し、各ハンドラに注入するよう修正しました。
*   **ロガーの統一**: `log`と`slog`の混在によって発生したコンパイルエラーを、`slog`に統一することで解消しました。

---

#### 次回のアクションプラン

**最優先タスク: 注文リクエスト生成ロジックの実装**

1.  **意思決定ロジックの強化**:
    *   **内容**: `agent.go`の`tick`メソッド内で、読み込んだシグナルと、同期済みの内部状態（ポジション、残高）に基づき、具体的な注文リクエスト（`PlaceOrderRequest`）を生成するロジックを実装します。これには、注文数量の決定（例: 設定ファイルの`lot_size`を使用）、注文種別の決定（例: まずは成行注文に固定）などが含まれます。
    *   **目的**: エージェントがシグナルと自身の状態に基づき、実行可能な注文内容を組み立てられるようにする。

---

## 実装から得られた知見（APIクライアント編）

本セクションでは、開発過程で遭遇した立花証券APIの特殊な仕様や、それに対する実装上のノウハウを記録する。

### 1. APIの環境差異とURLのバージョン管理

- **課題**: テスト環境とローカル環境で同じコードにも関わらず、ローカルでのみログインAPIが404エラーを返した。
- **原因**: APIのベースURLにバージョン情報（例: `v4r8`）が含まれており、ローカルの`.env`ファイルに設定されたURLのバージョンが古かった (`v4r7`)。
- **ノウハウ**:
    - APIへの接続テストが失敗する場合、コードのロジックだけでなく、`.env`ファイルに設定されたエンドポイントURL (`TACHIBANA_BASE_URL`など) が、テスト対象の環境で有効なものであるかを最初に確認する必要がある。
    - APIのバージョンアップに伴い、URLも変更される可能性があることを常に念頭に置く。

### 2. マスターデータ取得APIの特殊なストリーミング仕様

- **課題**: 全件マスターデータを取得する`DownloadMasterData` APIを呼び出すと、`bufio.Scanner: token too long`エラーが発生し、ストリームを最後まで読み取れなかった。
- **原因**: このAPIは、数万行に及ぶデータを、**改行なしの単一の巨大なライン、あるいは連続したJSONオブジェクト**としてストリーミング配信する特殊な仕様となっている。Go標準ライブラリの`bufio.Scanner`は改行をデリミтаとしており、この形式に対応できない。
- **解決策**: 公式のPythonサンプルコードのロジックを参考に、以下の手動パーシング処理を実装した。
    1. レスポンスボディを固定長のチャンク（例: 4096バイト）で読み込む。
    2. 読み込んだバイト列を一時的なバッファ (`bytes.Buffer`) に蓄積する。
    3. バッファ内にJSONオブジェクトの終端文字 (`}`) が存在するかを検索する。
    4. 終端文字が見つかった場合、そこまでを一つのJSONオブジェクト候補として切り出し、`json.Unmarshal`でデコードを試みる。
    5. デコードが成功した場合、バッファからその部分を削除し、次のオブジェクトの処理に移る。
    6. これを、APIから`CLMEventDownloadComplete`という完了通知オブジェクトが送られてくるまで繰り返す。
- **ノウハウ**:
    - ストリーミングAPIを扱う際は、データがどのような形式・区切り文字で送られてくるかを正確に把握することが極めて重要である。
    - 標準ライブラリで対応できない特殊な形式の場合、公式のサンプルコード（もしあれば）の挙動を模倣した、より低レベルなバイト/チャンク処理の実装が必要となる。

### 3. 認証とテスト環境の仕様 (2025-12-16 追記)

#### 3.1. 本番環境の二要素認証 (2FA)

- **課題**: 本番環境に対してログインAPIを実行すると、`result code 10088: 当社に登録の電話番号から認証電話番号へかけた後にログインしてください。` というエラーで失敗する。
- **原因**: 本番環境のAPIは、セキュリティ強化のため、ID/パスワード認証に加えて電話認証を要求する。具体的には、ログインリクエストを送信する**前**に、予め登録した電話番号から指定の認証用番号へ電話を発信する必要がある。
- **ノウハウ**:
    - **機能開始日時**: 2025年7月26日（土）システムメンテナンス終了以降
    - **API用認証電話番号**: 0120-28-6592 または 050-3102-6575（通話料有料）
    - この仕様のため、テストコードやCI/CDパイプライン内での完全自動ログインは不可能である。
    - 本番環境に対するテスト（データ取得など）を実行するには、以下の手動ステップが必要になる。
        1.  開発者が手動で電話認証を行い、`curl` などでログインを実行する。
        2.  成功したレスポンスから、後続のリクエストに必要なセッション情報（Cookie, 各種URL, `p_no`など）を抽出する。
        3.  抽出した情報を環境変数などを介してテストプログラムに渡し、ログイン済みの状態を擬似的に再現する。
    - **(2025-12-20 追記)** 電話認証の有効期間は**約3分**。この時間を超過すると`result code 10089`エラーでログインに失敗する。

#### 3.2. デモ環境のデータ制限

- **課題**: デモ環境に対して`GetPriceInfo`（株価照会）や`GetPriceInfoHistory`（時価履歴）などのAPIを実行すると、エラーにはならないが、レスポンスのデータ部分が空の配列で返ってくる。
- **原因**: APIの公式ドキュメントおよび実際の挙動から、デモ環境はAPIの接続性やリクエスト形式の検証を目的としており、リアルな株価データや履歴データを返却しない仕様であることが確認された。
- **ノウハウ**:
    - デモ環境を対象とするテストは、データが空で返ってくることを前提に実装する必要がある。
    - テストコード内では、レスポンスのデータ配列の長さが0より大きいか (`len(data) > 0`) を確認した上で、データ内容のアサーションを行うべきである。これにより、同じテストコードで、デモ環境では接続性の確認、本番環境ではデータ内容の正当性検証、という両方の役割を担うことができる。

#### 3.3. Cookieベースのセッション管理

- **課題**: ログイン後のセッションをどのように維持し、後続のリクエストで認証済み状態を伝えるか。
- **原因**: 多くのAPIで採用されている`Authorization`ヘッダー（Bearerトークンなど）ではなく、このAPIは **HTTP Cookie** (`_SID`など) を用いてセッションを管理している。
- **ノウハウ**:
    - APIと通信するHTTPクライアントは、`CookieJar`を有効にして、サーバーから送られてくる`Set-Cookie`ヘッダーを適切に保存・送信する必要がある。
    - 手動で本番テストを行う際は、ログインレスポンスの`Set-Cookie`ヘッダーの値が、認証を維持するための最も重要な情報となる。
    - **(2025-12-20 追記)** ログインのたびに、サーバーは**新しい独立したセッション**を確立する。これにより、クライアント側の`p_no`は常に`1`にリセットされる。古いセッションは、新しいログインによって無効化される可能性が高い（要検証: `TEST-006`）。

#### 3.4. 認証・アカウントロック時のエラーコードに関するドキュメントの不足 (2025-12-18 追記)

- **課題**: API利用における認証失敗時やアカウントロック状態に陥った際の、具体的なエラーコードやレスポンス形式に関する情報が不足している。
- **調査**: 公式の日本株APIリファレンスマニュアル (`https://www.e-shiten.jp/e_api/mfds_json_api_refference.html`) を確認したが、「電話認証前のエラー」や「アカウントロック状態」を示す具体的なエラーコードや詳細な記述は見当たらなかった。
- **ノウハウ**:
    - エラーハンドリングを実装する際は、エラーコードのみに依存せず、`ResultText`などのメッセージ内容やHTTPステータスコードを複合的に判断する必要がある。
    - また、APIからのレスポンスを詳細にログに記録し、実際の挙動からエラーパターンを特定する運用が必要となる。

#### 3.5. 認証に関するサポートからの回答 (2025-12-19 追記)

APIアカウントロック問題（`2025-12-17`）を受け、証券会社サポートに確認した結果、以下の仕様が判明した。これは、特に本番環境でのエージェントの安定稼働を設計する上で重要な制約となる。

-   **ログイン失敗カウントの分離**:
    -   デモ環境のログインAPIでの失敗は、デモ環境内でのみカウントされ、本番環境の失敗カウントには加算されない。これにより、デモ環境での認証関連テストは、本番アカウントのロックを心配せず実施できる。

-   **アカウントロックポリシーの非開示**:
    -   本番環境でアカウントロックに至るログイン失敗の正確な回数は**非開示**である。
    -   このため、本番環境でのログイン処理に自動リトライを組み込むことは、意図せずアカウントをロックさせる高いリスクを伴う。ログイン失敗時の処理は、即時通知と手動介入を基本方針とすべきである。

-   **ロック解除プロセス**:
    -   APIアクセスが原因でアカウントがロックされた場合、解除には**サポートセンターへの電話連絡が必須**となる。自動化された解除手段は存在しない。

-   **API利用可能時間帯**:
    -   APIサーバーは、データ更新のため毎日**午前3:30～5:30頃**にシステム停止する。これに伴い、電話認証やAPIセッションの開始も、この停止時間が終了した後から可能となる。エージェントの起動・再接続シーケンスは、この時間帯を考慮して設計する必要がある。

#### 3.6. ログイン/ログアウト時のP_no挙動と再ログインの可能性 (2025-12-19 追記)

実験とテストの結果、`p_no` および本番環境での再ログインについて以下の知見が得られた。

-   **`p_no` の挙動**:
    -   クライアントの `p_no` は、ログイン成功時にAPIからのレスポンスに含まれる値で初期化される。通常、最初のログイン成功時には `1` が設定される。
    -   `Logout` および `LogoutWithPost` メソッドの実行中には、`p_no` が1度インクリメントされる（`getPNo()`が呼び出されるため）。
    -   ログアウト後、再度ログインすると、`p_no` は新しいセッションの開始に伴い、再び `1` にリセットされる。これは、サーバーから新しいセッションの `p_no` が提供されるためである。

-   **本番環境での再ログインの可能性**:
    -   APIのドキュメントに明確な記載はないものの、エラーメッセージ「電話認証後、3分以内にログインしてください」から推測するに、一度電話認証を完了すれば、その**3分間の有効期間内**であれば、ログアウトしても再度のログインが可能である可能性が高い。
    -   ログアウトはセッションを切断するが、「電話認証によるログイン許可状態」を直ちにリセットするものではないと考えられる。この挙動は、開発中のテストで確認する必要がある。

#### 3.7. テストにおけるインタラクティブプロンプトの運用 (2025-12-19 追記)

`go test` 環境でのインタラクティブなプロンプトの挙動について、以下の知見が得られた。

-   **`go test` とインタラクティブプロンプトの相性**:
    -   `go test` は、テストコードからの標準入力 (`bufio.NewReader(os.Stdin)`) の読み取りをうまく扱えない場合がある。特にCI/CD環境や非対話的な実行では、入力待ちにならずに即座に処理が続行され、空の入力と判断されることがある。
-   **運用方針**:
    -   このため、電話認証の確認のような**インタラクティブなプロンプトは、開発者が意図的に対話的に実行するテストファイル内（例: `price_info_client_impl_prod_test.go`）に限定すべきである。**
    -   共通のテストヘルパー関数 (`CreateTestClient`) や、CI/CDで実行される可能性のあるテストファイルには、インタラクティブなプロンプトを含めるべきではない。これにより、テストの実行環境に依存しない安定したテスト運用が可能となる。


