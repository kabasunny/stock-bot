# システム設計に関する検討事項

## 1. はじめに

本ドキュメントは、Pythonによる売買判断ロジックと、Goによる証券会社API連携システムのアーキテクチャを具体化するにあたり、検討すべき主要な論点を整理することを目的とします。

## 2. 基本アーキテクチャ方針

-   **Goの役割**: 証券会社APIとの通信（データ取得、注文執行）に特化した堅牢なバックエンド。APIとの複雑なやり取りを抽象化し、安定したインターフェースを提供する責務を負う。
-   **Pythonの役割**: Goが提供するデータを元に、高度な分析、機械学習、売買戦略の判断など、コアとなるビジネスロジックを実行する。

## 3. 主要なワークフロー

### 3.1. シグナル系統
APIからリアルタイムデータを受信し、それを処理してPython側での分析・判断につなげる流れ。
1.  **クライアント(Go)**: 証券会社APIからリアルタイムのイベントデータ（価格、板情報など）を受信する。
2.  **イベントハンドラ(Go/Python)**: 受信データを共通形式に変換・加工する。
3.  **アクター(Python)**: 加工されたデータを元に、売買戦略に基づき分析・判断する。

### 3.2. 注文系統
Python側での判断結果に基づき、Goを通じて実際に注文を執行する流れ。
1.  **アクター(Python)**: 売買判断に基づき、具体的な注文内容（銘柄、数量など）を決定する。
2.  **サービス(Go)**: Pythonからの注文リクエストを受け付け、リスク管理などの横断的処理を担う。
3.  **ユースケース(Go)**: 注文処理の本体。クライアントを介して発注し、リポジトリに履歴を記録する。
4.  **クライアント(Go)**: 証券会社APIに注文データを送信する。
5.  **リポジトリ(Go)**: 注文・ポジション情報を永続化する。

## 4. 実装に向けた主要な検討事項 (Issue)

今後の開発を進める上で、以下の点について方針を決定する必要があります。

### Issue 1: リアルタイムイベントの受信方式の特定
-   **論点**: 利用する証券会社APIは、リアルタイムの株価情報や約定通知などをどのような形式（例: WebSocket、HTTPロングポーリング、特定のストリーミングプロトコル）で提供しているか？
-   **重要性**: この方式によって、Go側のクライアント(`internal/infrastructure/client`)の実装方法が大きく異なります。WebSocketであれば非同期の常時接続クライアントが、ポーリングであれば定期実行のHTTPクライアントが必要になります。

### Issue 2: Go-Python間の連携インターフェース設計
-   **論点A (Go -> Python)**: Goが取得したリアルタイムイベントデータを、どのようにPython側に連携するか？
    -   **案1**: GoがWebサーバーとなり、Pythonが定期的にAPIをポーリングしてデータを取得する。
    -   **案2**: Goがイベントを受信したら、Pythonの指定されたエンドポイントにHTTP POSTでデータをプッシュ通知する。
    -   **案3**: gRPCやMessage Queue（NATS, RabbitMQなど）を介して、より効率的な双方向通信を行う。
-   **論点B (Python -> Go)**: Pythonからの注文指示を、どのようにGo側に連携するか？
    -   **案**: Goが注文指示を受け付けるためのHTTP APIエンドポイント（例: `POST /orders`）を公開するのが最もシンプルで一般的です。
-   **データ形式**: 連携時のデータ形式（JSON, Protocol Buffersなど）も合わせて決定する必要があります。

### Issue 3: イベントハンドラの責務と実装場所
-   **論点**: APIからの生データを、どの程度Go側で加工・整形してからPythonに渡すか？
-   **検討点**:
    -   Go側では最低限の形式変換のみ行い、ロジック判断に必要な加工は極力Pythonに任せるか？
    -   あるいは、複数のAPIレスポンスをGo側でマージするなど、ある程度意味のある情報に集約してからPythonに渡すか？
    -   この決定は、GoとPython間のデータ連携スキーマ（API仕様）に直結します。

### Issue 4: Go側でのリスク管理の要否
-   **論点**: Pythonが売買判断の主体である一方、Go側で最終的なセーフティネットとしてのリスク管理（例: 異常な発注数量のチェック、口座残高を超える注文の拒否など）を実装すべきか？
-   **検討点**: もし実装する場合、どのレイヤー（`Usecase`層か、その上位の`Service`層か）に組み込むのが適切かを設計する必要があります。

## 5. 次のステップ

まずは、上記の **Issue 1** と **Issue 2** の方針を決定することが、具体的な実装に着手するための最優先事項となります。APIの仕様を確認し、システム全体のパフォーマンス要件を考慮しながら、最適な連携方式を選択しましょう。
