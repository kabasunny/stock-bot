# システム設計に関する検討事項

## 本ドキュメントの歩き方と運用ルール

本ドキュメントは、プロジェクトの全体像、現在のアーキテクチャ、主要な決定事項、未解決の課題、開発標準手順、そして直近の進捗と次のアクションプランを示す「要約」です。この「要約」は、常に**シンプルかつ明確**であることを最優先し、過度な詳細や冗長な記述を避けることを原則とします。

過去の詳細な開発経緯やデバッグの記録は、**`@planning/DEVELOPMENT_LOG.md`** に時系列で記載されています。

### 作業開始時の確認フロー

1.  **最初にここを見る**:
    まず、このファイル (`SYSTEM_DESIGN_MEMO.md`) の **`次回のアクションプラン`** セクションを確認してください。これが現在の最優先タスクリストです。
2.  **背景を理解する**:
    アクションプランの背景を理解するために、同ファイルの **`実装から得られた知見`** を確認します。最新の開発進捗については `DEVELOPMENT_LOG.md` の先頭を参照してください。
3.  **過去に遡る**:
    さらに詳細な経緯や過去の意思決定について知りたい場合は、**`@planning/DEVELOPMENT_LOG.md`** を参照してください。

### 開発進捗（Progress）の記録ルール (最優先事項)

本ドキュメントにおける「開発進捗」の記述は、以下の原則に厳密に従います。

*   **簡潔性**: 完了したタスクの概要と、その結果がプロジェクト全体にどのような影響を与えたか（例: 「〜により、動的な取引が可能になった」）を**戦略的レベルで簡潔に**記述します。
*   **高レベルの記述**: 実装の詳細、試行錯誤の過程、具体的なコードスニペット、APIレスポンスの断片などは一切含めません。これらはすべて後述の「詳細な記録」に記載します。
*   **更新タイミング**: 「次回のアクションプラン」に記載されたタスクが完了するたびに更新します。

### `次回のアクションプラン（Next Action Plan）` の運用 (最優先事項)

このセクションには、現在取り組むべき最優先タスクのみを、その「目的」と「具体的な作業内容」を明確にして記述します。冗長な記述は避け、常に実行可能なタスクとして提示します。

### `詳細な記録（Detailed Log）` の運用 (最優先事項)

すべての技術的な詳細、コード変更の理由、デバッグの経緯、発見された問題とその解決策、APIとのやり取りの具体例などは、**`@planning/DEVELOPMENT_LOG.md`** に時系列で記録します。このファイルはプロジェクトの「活動履歴」であり、いかなる詳細も許容されます。

### `専門ドキュメント（Specialized Documents）` の活用 (最優先事項)

特定の大きな設計タスク、深い技術調査、複雑なリファクタリング計画など、自己完結した内容については、`planning/` ディレクトリ内に新たな専用のマークダウンファイル（例: `PERFORMANCE_ANALYTICS_DESIGN.md`）を作成します。これにより、単一のドキュメントが肥大化するのを防ぎ、関連情報の検索性を高めます。

### 「実装から得られた知見」セクションの運用 (変更なし)

このセクションは、開発中に得られた重要なノウハウやAPIの仕様など、**現在頻繁に参照する必要がある知見**を記録する場所です。

*   **定期的な見直し**: プロジェクトのフェーズが進むにつれて、一部の知見は「当たり前のこと」になったり、参照頻度が低下したりします。陳腐化した情報や詳細すぎる情報は、定期的に **`@planning/DEVELOPMENT_LOG.md`** に移動させます。
*   **要約を心がける**: 新しい知見を追記する際は、結論と要点を簡潔に記述します。詳細な経緯や試行錯誤の記録は、`@planning/DEVELOPMENT_LOG.md` に記載します。

このルールにより、`SYSTEM_DESIGN_MEMO.md` は常に最新かつ重要な情報へのクイックリファレンスとして機能します。
---

## 1. はじめに

本ドキュメントは、株式自動取引システムのアーキテクチャを具体化するにあたり、検討すべき主要な論点を整理することを目的とします。
*(2025-12-06 追記: 当初の設計から議論を経て、より責務が明確な「エージェント中心」のアーキテクチャへと方針を更新した。以降の章は、この新しい方針を反映している。)*

## 2. 基本アーキテクチャ方針 (エージェント中心モデル)
システムは、責務が明確に分離された以下の3つのコンポーネントで構成される。

1.  **Go製 APIラッパー (Go API Wrapper)**
    -   **役割**: 証券会社APIとの直接的な通信（REST, WebSocket）をすべて担当し、その複雑さを抽象化する。
    -   **機能**: 外部からのHTTPリクエストに基づき、データ取得、注文執行などを行う。Goaフレームワークを用いて、堅牢なHTTP APIを公開する。
    -   https://github.com/e-shiten-jp?tab=repositories ここに参考のPythonコードがあるので、リクエストを作成する際の参考にする

2.  **Python製 シグナル生成サービス (Python Signal Generator)**
    -   **役割**: 高度な計算や機械学習モデルを用いて、売買シグナルを生成することに特化する。
    -   **機能**: 外部から市場データを受け取り、分析結果のシグナルを返すHTTP APIを公開する。自らは動かない受動的なコンポーネント。

3.  **エージェント (Agent)**
    -   **役割**: システム全体の「頭脳」であり、主体的な意思決定を行う中央司令塔。
    -   **機能**: 取引戦略のメインループとして、Go APIラッパー（データ取得/注文）とPythonサービス（シグナル問合せ）を呼び出し、全体のワークフローを指揮する。

## 3. 主要なワークフロー
すべてのワークフローは「エージェント」が起点となる。

1.  **エージェント**: データ取得のため **Go APIラッパー** を呼び出す。
2.  **Go APIラッパー**: 証券会社APIからデータを取得し、エージェントに返却する。
3.  **エージェント**: 受け取ったデータを **Pythonサービス** に渡し、売買シグナルを問い合わせる。
4.  **Pythonサービス**: データ分析を行い、シグナルをエージェントに返却する。
5.  **エージェント**: シグナルと自身のロジックに基づき売買を判断し、**Go APIラッパー** を呼び出して発注を指示する。

## 4. 実装計画と技術選択

### 4.1. 短期計画: Goによるモノリシックな実装
まず、迅速にプロトタイプを構築するため、**Go APIラッパー**と**エージェント**を単一のGoアプリケーション内のコンポーネントとして実装する。
- コンポーネント間の通信は、Goaで定義したHTTP APIを通じて行う (`localhost`経由)。これは将来的なサービス分割（次項）を見据えた疎結合な設計のためである。

### 4.2. 長期目標: エージェントのRust化
システムの安定稼働後、さらなるパフォーマンスと安全性を追求するため、**エージェントをRust製のマイクロサービスとして再実装し、独立させる**ことを最終目標とする。
- 初期段階で通信をHTTP APIに定めているため、Go製エージェNTをRust製エージェントに置き換える作業は、比較的スムーズに行える。

## 5. 実装に向けた主要な検討事項 (Issue)
*(このセクションは、新しいアーキテクチャの観点から再構成)*

### Issue 1: リアルタイムイベントの受信方式の特定 (変更なし)
-   **論点**: 利用する証券会社APIは、リアルタイムの株価情報や約定通知などをどのような形式で提供しているか？ (WebSocket, etc.)
-   **重要性**: Go APIラッパーの`EventClient`の実装方法に大きく影響する。

### Issue 2: コンポーネント間連携インターフェース設計 (更新)
-   **論点**: エージェント、Go APIラッパー、PythonサービスはそれぞれHTTP APIを介して通信する。Go APIラッパーのAPI設計にはGoaフレームワークを採用する。
-   **データ形式**: 連携時のデータ形式はJSONとする。

*(旧Issue 3, 4は新アーキテクチャにおいて責務が明確化されたため解消)*

---

### 専門ドキュメント

- **[バックテスト環境 設計書](./BACKTEST_DESIGN.md)**: 取引戦略の有効性を評価するためのバックテスト環境に関する設計ドキュメント。

### 開発標準手順

### リファクタリング標準手順 (2025-12-09 追記)
レイヤー間の責務移動など、アーキテクチャの健全性を維持するためのリファクタリングは、以下の手順書に従って実施する。
- **`planning/REFACTORING_PROCEDURE.md`**

### テスト戦略の基本方針 (2025-12-29 追記)
本プロジェクトでは、品質と開発効率を両立させるため、以下の2種類のテストを明確に区別し、使い分ける。

1.  **ユニットテスト (Unit Tests)**
    -   **役割**: 品質保証の**基盤**。個々の関数やコンポーネントが、単体で正しく動作することを保証する。
    -   **要件**:
        -   **高速であること**: 開発者が手元で頻繁に実行できるよう、ミリ秒単位で完了すること。
        -   **安定的であること**: ネットワークや外部APIの状態に依存せず、常に同じ結果を返すこと。
    -   **実現方法**: 外部APIやデータベースなどの依存関係は、**モック (Mock)** を使用して完全に分離する。これにより、様々な成功・失敗パターン（異常系、エッジケース）を網羅的にテストする。

2.  **結合テスト (Integration Tests)**
    -   **役割**:
        1.  **外部システムの振る舞いを発見する**: 未知の仕様を持つ外部APIに対し、実際にリクエストを送信して、その応答（データ形式、エラーコード等）を観測・収集する。
        2.  **主要なワークフローを検証する**: 複数のコンポーネントを連携させ、システム全体の主要なユースケースが正常に動作することを確認する。
    -   **位置づけ**: あくまで補助的なテストであり、不安定さや実行コストを許容する。ユニットテストを代替するものではない。

#### 開発ワークフロー
原則として、以下の順序で開発とテストを推進する。

1.  **発見 (Discovery)**: 外部APIの仕様が不明な場合、まず最小限の**結合テスト**を実施し、APIの振る舞いを記録するための「お手本データ」を収集する。
2.  **実装と堅牢化 (Implementation & Hardening)**: 収集した「お手本データ」を返すモックを作成し、それを用いて網羅的な**ユニットテスト**を記述する（テスト駆動開発）。
3.  **検証 (Verification)**: 主要機能の実装後、最終的な動作確認として**結合テスト**を実行する。

このアプローチにより、外部環境への依存を最小限に抑えつつ、システムの信頼性を高める。

### 共通操作におけるユーザーとの連携方針

プロジェクトのビルド、アプリケーションサーバーの起動、および `curl` コマンドなどによるAPIエンドポイントのテストといった、システムの状態を変更したり、外部との連携を伴う共通操作については、以下の原則に基づきユーザーに実行を依頼する。

-   **ビルド操作**: `go build` 等のビルドコマンド。
-   **アプリケーションサーバーの起動**: `go run` やコンパイル済みバイナリの実行など。
-   **外部連携コマンド**: `curl`, `Invoke-WebRequest` など、APIエンドポイントへのリクエスト送信。

これは、ユーザー環境への影響を最小限に抑え、各ステップにおいてユーザーの明示的な承認を得るためのものである。

### Goaサービス実装の標準手順 (2025-12-07 追記)

GoaでAPIサービスを実装する際の標準的な手順を以下に定める。これは、テスト駆動開発(TDD)のアプローチを取り入れ、堅牢なシステム構築を目指すものである。すべてのGoaサービス実装において、この手順に統一して開発を進めること。

**ゴール**: 特定のAPIエンドポイントが、クライアントから受け取った情報に基づき、インフラ層のクライアントを呼び出し、必要な処理を実行して、その結果を返す。

**前提**: Goaの設計ファイル (`design/design.go`) にAPI定義が完了しており、`goa gen` によってコードが自動生成されていること。また、インフラ層の外部APIクライアントは単体テストが完了していること。

#### ステップ1: ユースケースの「振る舞い」をテストで定義する (TDD)
目的: `UseCase` が持つべき振る舞いをテストで定義する。

1.  **テストファイル作成**: `internal/app/<service_name>_usecase_impl_test.go` を新規作成。
2.  **テスト内容**:
    *   モック（例: `OrderRepository`, `TachibanaOrderClient`）を準備し、`UseCase` が依存するコンポーネントが期待通りに呼び出されることを検証する。
    *   成功ケース、失敗ケース、バリデーションエラーなど、主要なシナリオに対するテストケースを記述する。
3.  **実行**: `go test ./internal/app/...` を実行。テストはコンパイルエラーまたは失敗するはず。これが、次の実装の明確なゴールとなる。

#### ステップ2: テストをパスさせるユースケースを実装する
目的: ステップ1で書いたテストをパスさせる。

1.  **実装ファイル作成**: `internal/app/<service_name>_usecase_impl.go` を新規作成。
2.  **実装内容**:
    *   `<Service>UseCaseImpl` 構造体を定義し、依存する `Repository` や `Client` をフィールドに持つ。
    *   `Execute<Service>` メソッド（または対応するメソッド）を実装する。この中で、インフラ層のクライアントを呼び出し、ビジネスロジックを実行する。
3.  **実行**: `go test ./internal/app/...` を実行し、**ステップ1のテストがすべてパスする**まで実装を修正する。

#### ステップ3: アプリケーション起動時の依存性注入 (DI)
目的: アプリケーション起動時に、各コンポーネントを正しく組み立てる。

1.  **ファイル修正**: `cmd/myapp/main.go` を修正。
2.  **実装内容**:
    *   インフラ層のクライアント、リポジトリのインスタンスを作成。
    *   上記を `New<Service>UseCaseImpl` に渡して `UseCase` のインスタンスを作成。
    *   作成した `UseCase` を `web.New<Service>Service` に渡して `Service` (ハンドラ) のインスタンスを作成。
    *   Goaサーバーに `Service` を登録する。
3.  **実行**: `go run ./cmd/myapp/main.go` を実行し、コンパイルエラーや起動時エラーが出ないことを確認する。

#### ステップ4: ハンドラとユースケースのつなぎこみ
目的: APIハンドラから、DIされたユースケースを呼び出す。

1.  **ファイル修正**: `internal/handler/web/<service_name>_service.go` を修正。
2.  **実装内容**:
    *   Goaの `Payload` を `app.Params` に変換する。
    *   `s.usecase.Execute<Service>(...)` を呼び出す。
    *   結果をGoaの `Result` に変換して返す。

#### ステップ5: 統合テスト
目的: APIエンドポイントを実際に呼び出し、システム全体が正しく連携して動作することを確認する。

1.  **実行**:
    1.  `go run ./cmd/myapp/main.go` でサーバーを起動。
    2.  `curl` などのツールで対象のAPIエンドポイントを呼び出す。
2.  **確認**:
    *   期待通りのHTTPステータスコードとレスポンスボディが返ってくること。
    *   (必要に応じて) データベースや外部システムのログなどで、処理が正しく行われたことを確認する。



Invoke-WebRequest -Uri http://localhost:8080/order -Method POST  -Headers @{"Content-Type"="application/json"} -Body '{"symbol":"6658","trade_type":"BUY","order_type":"MARKET","quantity":100}'

---



## 開発進捗（2025-12-22）

### 価格情報取得サービス (`price`) の実装と環境構築
-   **Goaサービス定義の追加とコード生成**:
    -   `design/design.go` に `price` サービス（`GET /price/{symbol}`）と `StockbotPrice` 型を定義しました。
    -   `goa gen stock-bot/design` コマンドを実行し、`price` サービスに対応するGoaクライアント、サーバー、ユースケースのボイラープレートコードを自動生成しました。
-   **`price` ユースケースの実装とテスト**:
    -   `internal/app/price_usecase.go` で `PriceUseCase` インターフェースを定義しました。
    -   `mockery` をインストールし、`internal/infrastructure/client/PriceInfoClient` のモックを生成しました。
    -   `internal/app/price_usecase_impl_test.go` で `PriceUseCase` のテスト（成功ケース、複数のエラーケース）を定義し、パスすることを確認しました。
    -   `internal/app/price_usecase_impl.go` で `PriceUseCaseImpl` を実装し、全てのテストがパスすることを確認しました。実装には、`PriceInfoClient` からのデータ取得、文字列からfloat64への変換、エラーハンドリングを含みます。
-   **Goaハンドラの実装**:
    -   `internal/handler/web/price_service.go` でGoaハンドラ `PriceService` を実装し、`PriceUseCase` を呼び出すようにしました。
-   **アプリケーション起動時の依存性注入 (DI)**:
    -   `cmd/myapp/main.go` を修正し、`price` サービス関連の依存性注入（`PriceUseCase`、`web.PriceService` の初期化とGoaサーバーへのマウント）を組み込みました。
-   **環境セットアップ**:
    -   `docker compose up -d` コマンドでデータベースコンテナを含むDocker環境を起動しました。
    -   `go run ./cmd/migrator/main.go` でデータベースのマイグレーションを正常に適用しました。
    -   `go run ./cmd/myapp/main.go` でアプリケーションがコンパイルエラーなく起動することを確認しました（ユーザーによるキャンセル）。

---

## 開発進捗（2025-12-23）

### 注文リクエスト生成ロジックの実装とログ強化
-   **注文リクエスト生成ロジック**: `agent.go`の`tick`メソッド内で、シグナルと内部状態（ポジション、残高）に基づいた`PlaceOrderRequest`の生成ロジック（注文数量の決定、成行注文固定など）が既に実装されていることを確認し、本タスクを完了としました。
-   **ログ強化**: `agent.go`の`tick`メソッドに、現在のポジションと注文の詳細をログ出力する機能を追加し、エージェントの内部状態の可視性を向上させました。

### シグナルファイル選択ロジックの改善
-   **FindSignalFile関数の強化**: `agent.go`の`FindSignalFile`関数を修正し、`signalPattern`に一致する複数のシグナルファイルが見つかった場合、最も更新日時が新しいファイルを優先的に選択するようにロジックを強化しました。これにより、エージェントが常に最新のシグナルに基づいて意思決定を行えるようになります。
-   **ユニットテストの追加**: `agent_test.go`に`FindSignalFile`関数の改善されたロジック（特に更新日時による選択）を検証するユニットテストを追加し、修正された関数の動作が意図通りであることを保証しました。

### エージェントのコンテキスト管理最適化
-   **tickメソッドにおけるコンテキストの最適化**: `agent.go`の`tick`メソッド内で`PlaceOrder`呼び出しに使用されている`context.WithTimeout`を、ループの外で一度生成し、それを各シグナルの処理に渡すように変更しました。これにより、ループ内での不必要なコンテキストの生成と破棄を避け、リソースの消費を抑え、コードの効率性を向上させました。

### 動的ポジションサイジングロジックの実装（第一段階）
-   **目的**: 固定ロット数による注文を、口座の資金状況とリスク許容度を考慮した動的な数量決定ロジックに置き換え、エージェントの取引判断をより実践的にしました。
-   **実装**:
    -   `agent_config.yaml`に`trade_risk_percentage`と`unit_size`を追加しました。
    -   `TradeService`インターフェースを拡張し、`price`サービスを呼び出す`GetPrice`メソッドを実装しました。
    -   `agent.go`の`tick`メソッド内で、買付余力と現在価格、設定ファイルのリスク許容度に基づき、動的に注文数量を計算するロジックを実装しました。

### `GoaTradeService.PlaceOrder` の実装と注文の永続化
-   **目的**: エージェントが発行する注文を実際に証券会社APIに送信し、その注文情報をデータベースに永続化する仕組みを構築しました。
-   **実装**:
    -   `goa_trade_service.go`の`PlaceOrder`メソッドを実装し、実際のAPI呼び出しとDB保存を行うようにしました。
    -   注文に必要な第二パスワードを`config`から読み込むように修正し、`orderRepo`を`GoaTradeService`に注入しました。

---
## 開発進捗（2025-12-25, Part2）

### 逆指値注文実装の試行とデバッグ
-   **逆指値注文の実装に着手**: `GoaTradeService` と `Agent` ロジックの変更に着手しました。
-   **サイレントクラッシュ問題の発生と原因特定**:
    -   逆指値注文のロジックを実装したところ、アプリケーションがエラーログを出力せずに起動しなくなる「サイレントクラッシュ」問題が発生しました。
    -   `go build` は成功することから、ランタイムエラーであると判断しました。
    -   実装した変更を一つずつ元に戻すことで問題を切り分け、原因が `goa_trade_service.go` の `PlaceOrder` 関数に対して行った、大規模なリファクタリングにあることを特定しました。
-   **現状復帰**: 問題解決と次回への準備のため、関連する変更をすべて元に戻し、アプリケーションが正常に起動する安定した状態に復元しました。

---

## 開発進捗（2025-12-25）

### エージェントの基盤機能の完成と検証
-   **状態同期機能**: エージェントが起動時に、現物・信用の全ポジションと未約定注文を正確に同期する機能が完成しました。
-   **注文執行機能**: 注文APIの必須パラメータをすべて実装し、安定した成り行き注文の発行が可能になりました。重複注文防止ロジックも正常に機能しています。
-   **指値注文の内部実装検証**: エージェントが指値注文を生成し、システムがそれを処理できることを確認しました。（テストコードはクリーンアップ済み）

---

## 開発進捗（2025-12-26）

### 逆指値注文機能の実装完了
-   **目的**: 売り注文に対して、損切り（ストップロス）のための逆指値注文機能を実装する。
-   **実装**:
    -   `goa_trade_service.go`の`PlaceOrder`メソッドを修正し、逆指値注文のパラメータをAPIの仕様に合わせて正しくマッピングするようにした。
    -   単体テストとAPIドキュメントを参考に、`GyakusasiZyouken`（トリガー価格）と`GyakusasiPrice`（執行価格）の役割を正しく実装した。
-   **検証**: 一時的なテストコードを用いて、逆指値注文（Stop-Market Order）がAPIエラーなく正常に発行されることを確認した。

---

## 開発進捗（2025-12-27, Part2）



### ATR（Average True Range）に基づく動的なポジションサイジング機能の実装

-   **目的**: 固定リスク率による注文数量の決定ロジックを、銘柄のボラティリティを考慮したATRベースの計算に置き換え、リスク管理の精度を向上させる。

-   **API拡張**: 履歴価格データを取得するための`GET /price/{symbol}/history`エンドポイントをGoaで設計・実装しました。

-   **設定追加**: `agent_config.yaml`にATRの計算期間（`atr_period`）やリスク係数（`risk_per_atr`）などのパラメータを追加しました。

-   **ロジック更新**: エージェントの`checkSignalsForEntry`関数内で、`GetPriceHistory`を呼び出してATRを算出し、それに基づいて注文数量を動的に決定するロジックを実装しました。



### 決済ロジックの単体テスト実装と堅牢化

-   エージェントの決済ロジック（`checkPositionsForExit`）に対して、利確、損切り、トレーリングストップの各シナリオを網羅する単体テストを実装しました。

-   テストを通じて発見された複数のコンパイルエラーやロジックの不具合を修正し、エージェントの中核機能の安定性を高めました。



---



## 開発進捗（2025-12-27）

### リアルタイムイベント受信機能の基盤実装とコンパイルエラーの解消
-   **リアルタイムイベント受信機能**: WebSocketクライアントの基盤を実装し、エージェントへの統合を完了しました。これにより、WebSocketへの接続、メッセージの受信、ログ出力までの一連のフローが確立されました。
-   **コンパイルエラーの解消**:
    -   ロガーの型不一致（`slog`と`zap`）の問題を解消するため、`event_client_impl.go`のロガーを`slog`に統一しました。
    -   WebSocketの独自メッセージ形式をパースする`ParseMessage`関数が`event_client_impl.go`から欠落していた問題を修正し、テストが通るようにしました。

### エージェントの自律的な決済ロジック（固定レート）の実装
-   **自動損切り・利確ロジック**: `agent.go`の`tick`メソッドを拡張し、保有ポジションの現在価格を監視して、`agent_config.yaml`で設定された`profit_take_rate`（利確率）または`stop_loss_rate`（損切り率）の閾値に達した場合に、自動的に成行の決済売り注文を発行する機能を実装しました。重複注文のチェック機構も組み込まれています。
-   **Helperメソッドの追加**: 注文が未約定であるかを判定する`IsUnexecuted`メソッドを`domain/model/order.go`に追加し、ロジックの可読性と堅牢性を向上させました。

### トレーリングストップ機能の実装着手
-   **設定パラメータの定義**: `agent_config.yaml`と`internal/agent/config.go`に、トレーリングストップの動作を制御する`trailing_stop_trigger_rate`と`trailing_stop_rate`を追加しました。
-   **Positionモデルの拡張**: `domain/model/position.go`の`Position`構造体に、トレーリングストップの追跡に必要な`HighestPrice`と`TrailingStopPrice`フィールドを（メモリ上でのみ利用する`gorm:"-"`タグ付きで）追加しました。

---
## 開発進捗（2025-12-28, Part2）

### バックテスト環境の安定化とポジションサイジングロジックの改善
-   **目的**: バックテスト実行時に発生していた重複注文や、非現実的な資金配分の問題を解決し、取引戦略の評価環境を安定させる。
-   **実装**:
    -   **状態同期の強化**: エージェントの `tick` メソッドの開始時に、残高だけでなくポジションと注文情報も `TradeService` から取得し、内部状態を完全に同期するように修正しました。これにより、エージェントは常に最新のポートフォリオを認識し、重複注文などの誤った意思決定を防ぐことができます。
    -   **ポジションサイジングの改善**: 1回の取引に資金が過度に集中する問題を解決するため、`agent_config.yaml`に `max_position_size_percentage`（例: 購買力の25%まで）という設定を追加しました。注文数量の計算時にこの上限を考慮させることで、より現実的な資金分散を実現しました。
-   **検証**: 上記の修正を適用したバックテストを実行し、エージェントが複数の銘柄に適切に資金を分散させ、かつ重複注文なしに安定して動作することを確認しました。

---

## 開発進捗（2025-12-28）

### `HighestPrice`の永続化と決済ロジックの堅牢化
-   **目的**: トレーリングストップ機能の耐障害性を向上させるため、ポジションごとの最高値をデータベースに永続化する。
-   **実装**:
    -   `domain/model/position.go` の `HighestPrice` フィールドから `gorm:"-"` タグを削除し、データベースのカラムとしてマッピングされるように変更しました。
    -   `positions` テーブルに `highest_price` カラムを追加するためのデータベースマイグレーションを作成し、適用しました。
    -   `PositionRepository` を拡張し、`HighestPrice` を更新するメソッドを追加実装しました。
    -   エージェントの決済ロジック (`checkPositionsForExit`) をリファクタリングし、`HighestPrice` 更新時にデータベースへの保存処理を組み込みました。
-   **堅牢化**: 上記変更に伴い、テストコードを修正し、`PositionRepository` のモックを追加することで、決済ロジックのテストカバレッジと信頼性を維持・向上させました。また、一連の修正過程で発生した複数のコンパイルエラーを解消しました。

### バックテスト環境の構築とデバッグ
-   **目的**: 開発した取引戦略の有効性を評価するためのバックテスト環境を構築し、発生した問題を解消する。
-   **実装**:
    -   `data/history`ディレクトリの作成。
    -   `7203.csv`, `6758.csv`, `9984.csv`のダミー履歴価格CSVファイルを作成し、`data/history`に配置。
    -   CSVを読み込み、パースするためのGoコード（`internal/data/price_history_reader.go`）を実装。
    -   `agent.TradeService`インターフェースを満たす`internal/agent/backtest_trade_service.go`を実装。
    -   バックテスト実行エンジン`cmd/backtester/main.go`を実装。
    -   `internal/agent/agent.go`に`SetLogger`、`Tick`、`SyncInitialState`メソッドを追加。
    -   `internal/agent/trade_service.go`の`HistoricalPrice.Volume`の型を`int64`に統一。
    -   `internal/agent/backtest_trade_service.go`のフィールドを公開化し、メソッド内の参照を修正。
    -   `cmd/backtester/main.go`の`targetSymbols`をサフィックスなしに統一。
    -   `cmd/backtester/main.go`の`initialCash`を1000万円、`agent_config.yaml`の`trade_risk_percentage`を`0.02`に設定。
    -   `cmd/backtester/main.go`のループを、全銘柄の履歴データの日付をユニークにしてソートしたリストを基準に回すように修正。
    -   `internal/agent/backtest_trade_service.go`の`GetPrice`および`GetPriceHistory`メソッドを、指定日付のデータがない場合に直近の過去データを返すように修正。
    -   `internal/agent/agent.go`の`checkSignalsForEntry`内のポジションサイジングロジックを修正。`riskPerATR`を削除し、`stopLossATRMultiplier`を使用するように統一。
    -   上記修正に伴い発生した全てのコンパイルエラーを解消。

---

## 開発進捗（2025-12-28, Part3）

### リアルタイム約定通知の処理機能実装とシステム統合

-   **目的**: WebSocket経由で受信したリアルタイムの約定通知を処理し、システムの内部状態（ポジション、注文状況）とデータベースを正確に更新するエンドツーエンドの機能を実装する。
-   **実装**:
    -   **ドメイン層**: `domain/model`に約定情報を表現する`Execution`モデルを定義し、`OrderRepository`と`PositionRepository`に約定を処理するためのメソッド（`UpdateOrderStatusByExecution`, `UpsertPositionByExecution`など）を追加しました。
    -   **アプリケーション層**: TDDアプローチに基づき、約定情報を受け取って各リポジトリを呼び出す`ExecutionUseCase`とその実装`ExecutionUseCaseImpl`を`internal/app`に作成しました。
    -   **インフラストラクチャ層**: `OrderRepositoryImpl`と`PositionRepositoryImpl`に、約定情報に基づいてデータベースを更新する具体的なロジックを実装しました。
    -   **エージェント層**: `Agent`構造体に`ExecutionUseCase`を注入し、`watchEvents`メソッド内で約定通知イベント（`p_cmd`が`"EX"`のケース）をハンドリングする`handleExecution`メソッドを実装しました。これにより、WebSocketで受信したメッセージがパースされ、`ExecutionUseCase`を通じて状態が更新されるフローが完成しました。
-   **堅牢化とリファクタリング**:
    -   本機能の実装に伴い、`agent`パッケージと`app`パッケージで発生したコンパイルエラーとテストの不整合をすべて解消しました。
    -   `agent.go`の決済ロジック`checkPositionsForExit`をリファクタリングし、ATR計算が失敗しても他の決済条件（利確など）のチェックが続行されるように改善しました。
    -   テストコードの信頼性を向上させるため、テストケースごとにモックを初期化するなどの修正を行いました。

---

## 開発進捗（2025-12-28, Part4）

### アプリケーションサーバーの起動安定化とエージェントの周期処理の確認

-   **目的**: 以前発生していたアプリケーション起動時のパニックを解消し、サーバーの安定稼働を実現する。また、アプリケーション内部のエージェントが周期的な処理を正しく実行していることを確認する。
-   **実装**:
    -   `internal/infrastructure/client/session.go`において、`Session`構造体内の`CookieJar`が正しく初期化されるよう修正を適用しました。これにより、`CookieJar`のメソッド呼び出し時のnilポインタ参照エラーを解消しました。
    -   `internal/infrastructure/client/event_client_impl.go`において、`session.EventURL`からCookieを取得する際に、nilではなくパース済みの`*url.URL`を渡すように修正しました。
    -   `internal/infrastructure/client/event_client_impl.go`に`net/url`のimportを追加しました。
-   **検証**:
    -   `go run ./cmd/myapp/main.go --skip-sync` コマンドでアプリケーションがコンパイルエラーなく、かつパニックを起こさずに正常に起動することを確認しました。
    -   起動後、ログに「agent tick」メッセージが一定時間（約9～10秒）ごとに繰り返し出力されており、エージェントが意図通り周期的な処理を実行していることを確認しました。この処理には、内部状態の同期や取引シグナルのチェックなどが含まれます。
    -   WebSocket接続時に「malformed ws or wss URL」のエラーがログに出力されていますが、これはHTTP/HTTPSスキームをWS/WSSに変換する必要があるためと考えられます。ただし、アプリケーションの主要機能は引き続き動作しており、この問題は今後のWebSocket関連の改善タスクとして認識されました。

---
#### 次回のアクションプラン

**最優先タスク: プロジェクト全体のテストの安定化とクリーンアップ**

1.  **目的**:
    *   プロジェクト全体のテストスイートを安定させ、CI/CD環境でも常に信頼できるフィードバックが得られる状態を構築する。また、開発中に導入した一時的なコードをクリーンアップする。

2.  **現状と次のステップ**:
    *   **現状**:
        *   `internal/agent`と`internal/app`のユニットテストは安定してパスしている。
        *   `internal/infrastructure`配下のテストは、環境設定（`.env`ファイルやDocker）に依存しており、ローカル環境で頻繁に失敗している。
    *   **次ステップ1（テストの安定化）**:
        *   `internal/infrastructure/client`のテストを修正し、`TachibanaClient`のテストが`.env`ファイルに依存しないようにする。テスト用の設定値を直接渡すか、テスト専用の設定ファイルを使用するアプローチを検討する。
        *   `internal/infrastructure/repository`のテストで利用している`testcontainers-go`がDockerに接続できない問題を解決する。Dockerが実行中であることを前提とするか、Dockerが利用できない環境ではテストをスキップするビルドタグ（例: `//go:build integration`）の導入を検討する。
    *   **次ステップ2（プレースホルダーの実装）**:
        *   `agent.go`内に残っているプレースホルダー関数`handlePriceData`と`handleStatus`の具体的な実装に着手する。これにより、リアルタイムイベントの処理がより完全なものになる。
        *   **12/30接続テスト**: 証券会社APIとの接続テストにおいて、WebSocket経由で受信する「約定通知」メッセージの具体的なフォーマット（キーと値）を特定する。

#### 先行検討事項 (Pre-emptive Considerations)

明日のテストに影響を与えない範囲で、将来のタスクを見据えて以下の事項を検討する。

1.  **Pythonシグナル生成サービスAPIの検討**:
    *   `SYSTEM_DESIGN_MEMO.md`に記載の「Python製シグナル生成サービス」がHTTP APIを公開する際のエンドポイント、リクエスト形式、レスポンス形式の素案を仮説的に検討する。

2.  **バックテスト戦略パラメータの再確認と評価指標の検討**:
    *   `agent_config.yaml`に設定されている既存の戦略パラメータを確認し、将来的な最適化の可能性や、バックテストで「何をもって成功と判断するか」という評価指標（P/L, ドローダウンなど）を検討する。

3.  **本番デプロイ・運用・監視の初期検討**:
    *   Goアプリケーションの本番環境へのデプロイ方法、稼働監視、ログ収集、アラート設定など、基本的な運用戦略について情報収集や思考実験を行う。

---

## 実装から得られた知見（APIクライアント編）

本セクションでは、開発過程で遭遇した立花証券APIの特殊な仕様や、それに対する実装上のノウハウを記録する。

### 1. APIの環境差異とURLのバージョン管理

- **課題**: テスト環境とローカル環境で同じコードにも関わらず、ローカルでのみログインAPIが404エラーを返した。
- **原因**: APIのベースURLにバージョン情報（例: `v4r8`）が含まれており、ローカルの`.env`ファイルに設定されたURLのバージョンが古かった (`v4r7`)。
- **ノウハウ**:
    - APIへの接続テストが失敗する場合、コードのロジックだけでなく、`.env`ファイルに設定されたエンドポイントURL (`TACHIBANA_BASE_URL`など) が、テスト対象の環境で有効なものであるかを最初に確認する必要がある。
    - APIのバージョンアップに伴い、URLも変更される可能性があることを常に念頭に置く。

### 2. マスターデータ取得APIの特殊なストリーミング仕様

- **課題**: 全件マスターデータを取得する`DownloadMasterData` APIを呼び出すと、`bufio.Scanner: token too long`エラーが発生し、ストリームを最後まで読み取れなかった。
- **原因**: このAPIは、数万行に及ぶデータを、**改行なしの単一の巨大なライン、あるいは連続したJSONオブジェクト**としてストリーミング配信する特殊な仕様となっている。Go標準ライブラリの`bufio.Scanner`は改行をデリミたとしており、この形式に対応できない。
- **解決策**: 公式のPythonサンプルコードのロジックを参考に、以下の手動パーシング処理を実装した。
    1. レスポンスボディを固定長のチャンク（例: 4096バイト）で読み込む。
    2. 読み込んだバイト列を一時的なバッファ (`bytes.Buffer`) に蓄積する。
    3. バッファ内にJSONオブジェクトの終端文字 (`}`) が存在するかを検索する。
    4. 終端文字が見つかった場合、そこまでを一つのJSONオブジェクト候補として切り出し、`json.Unmarshal`でデコードを試みる。
    5. デコードが成功した場合、バッファからその部分を削除し、次のオブジェクトの処理に移る。
    6. これを、APIから`CLMEventDownloadComplete`という完了通知オブジェクトが送られてくるまで繰り返す。
- **ノウハウ**:
    - ストリーミングAPIを扱う際は、データがどのような形式・区切り文字で送られてくるかを正確に把握することが極めて重要である。
    - 標準ライブラリで対応できない特殊な形式の場合、公式のサンプルコード（もしあれば）の挙動を模倣した、より低レベルなバイト/チャンク処理の実装が必要となる。

### 3. 認証とテスト環境の仕様 (2025-12-16 追記)

#### 3.1. 本番環境の二要素認証 (2FA)

- **課題**: 本番環境に対してログインAPIを実行すると、`result code 10088: 当社に登録の電話番号から認証電話番号へかけた後にログインしてください。` というエラーで失敗する。
- **原因**: 本番環境のAPIは、セキュリティ強化のため、ID/パスワード認証に加えて電話認証を要求する。具体的には、ログインリクエストを送信する**前**に、予め登録した電話番号から指定の認証用番号へ電話を発信する必要がある。
- **ノウハウ**:
    - **機能開始日時**: 2025年7月26日（土）システムメンテナンス終了以降
    - **API用認証電話番号**: 0120-28-6592 または 050-3102-6575（通話料有料）
    - この仕様のため、テストコードやCI/CDパイプライン内での完全自動ログインは不可能である。
    - 本番環境に対するテスト（データ取得など）を実行するには、以下の手動ステップが必要になる。
        1.  開発者が手動で電話認証を行い、`curl` などでログインを実行する。
        2.  成功したレスポンスから、後続のリクエストに必要なセッション情報（Cookie, 各種URL, `p_no`など）を抽出する。
        3.  抽出した情報を環境変数などを介してテストプログラムに渡し、ログイン済みの状態を擬似的に再現する。
    - **(2025-12-20 追記)** 電話認証の有効期間は**約3分**。この時間を超過すると`result code 10089`エラーでログインに失敗する。

#### 3.2. デモ環境のデータ制限

- **課題**: デモ環境に対して`GetPriceInfo`（株価照会）や`GetPriceInfoHistory`（時価履歴）などのAPIを実行すると、エラーにはならないが、レスポンスのデータ部分が空の配列で返ってくる。
- **原因**: APIの公式ドキュメントおよび実際の挙動から、デモ環境はAPIの接続性やリクエスト形式の検証を目的としており、リアルな株価データや履歴データを返却しない仕様であることが確認された。
- **ノウハウ**:
    - デモ環境を対象とするテストは、データが空で返ってくることを前提に実装する必要がある。
    - テストコード内では、レスポンスのデータ配列の長さが0より大きいか (`len(data) > 0`) を確認した上で、データ内容のアサーションを行うべきである。これにより、同じテストコードで、デモ環境では接続性の確認、本番環境ではデータ内容の正当性検証、という両方の役割を担うことができる。

#### 3.3. Cookieベースのセッション管理

- **課題**: ログイン後のセッションをどのように維持し、後続のリクエストで認証済み状態を伝えるか。
- **原因**: 多くのAPIで採用されている`Authorization`ヘッダー（Bearerトークンなど）ではなく、このAPIは **HTTP Cookie** (`_SID`など) を用いてセッションを管理している。
- **ノウハウ**:
    - APIと通信するHTTPクライアントは、`CookieJar`を有効にして、サーバーから送られてくる`Set-Cookie`ヘッダーを適切に保存・送信する必要がある。
    - 手動で本番テストを行う際は、ログインレスポンスの`Set-Cookie`ヘッダーの値が、認証を維持するための最も重要な情報となる。
    - **(2025-12-20 追記)** ログインのたびに、サーバーは**新しい独立したセッション**を確立する。これにより、クライアント側の`p_no`は常に`1`にリセットされる。古いセッションは、新しいログインによって無効化される可能性が高い（要検証: `TEST-006`）。

#### 3.4. 認証・アカウントロック時のエラーコードに関するドキュメントの不足 (2025-12-18 追記)

- **課題**: API利用における認証失敗時やアカウントロック状態に陥った際の、具体的なエラーコードやレスポンス形式に関する情報が不足している。
- **調査**: 公式の日本株APIリファレンスマニュアル (`https://www.e-shiten.jp/e_api/mfds_json_api_refference.html`) を確認したが、「電話認証前のエラー」や「アカウントロック状態」を示す具体的なエラーコードや詳細な記述は見当たらなかった。
- **ノウハウ**:
    - エラーハンドリングを実装する際は、エラーコードのみに依存せず、`ResultText`などのメッセージ内容やHTTPステータスコードを複合的に判断する必要がある。
    - また、APIからのレスポンスを詳細にログに記録し、実際の挙動からエラーパターンを特定する運用が必要となる。

#### 3.5. 認証に関するサポートからの回答 (2025-12-19 追記)

APIアカウントロック問題（`2025-12-17`）を受け、証券会社サポートに確認した結果、以下の仕様が判明した。これは、特に本番環境でのエージェントの安定稼働を設計する上で重要な制約となる。

-   **ログイン失敗カウントの分離**:
    -   デモ環境のログインAPIでの失敗は、デモ環境内でのみカウントされ、本番環境の失敗カウントには加算されない。これにより、デモ環境での認証関連テストは、本番アカウントのロックを心配せず実施できる。

-   **アカウントロックポリシーの非開示**:
    -   本番環境でアカウントロックに至るログイン失敗の正確な回数は**非開示**である。
    -   このため、本番環境でのログイン処理に自動リトライを組み込むことは、意図せずアカウントをロックさせる高いリスクを伴う。ログイン失敗時の処理は、即時通知と手動介入を基本方針とすべきである。

-   **ロック解除プロセス**:
    -   APIアクセスが原因でアカウントがロックされた場合、解除には**サポートセンターへの電話連絡が必須**となる。自動化された解除手段は存在しない。

-   **API利用可能時間帯**:
    -   APIサーバーは、データ更新のため毎日**午前3:30～5:30頃**にシステム停止する。これに伴い、電話認証やAPIセッションの開始も、この停止時間が終了した後から可能となる。エージェントの起動・再接続シーケンスは、この時間帯を考慮して設計する必要がある。

#### 3.6. ログイン/ログアウト時のP_no挙動と再ログインの可能性 (2025-12-19 追記)

実験とテストの結果、`p_no` および本番環境での再ログインについて以下の知見が得られた。

-   **`p_no` の挙動**:
    -   クライアントの `p_no` は、ログイン成功時にAPIからのレスポンスに含まれる値で初期化される。通常、最初のログイン成功時には `1` が設定される。
    -   `Logout` および `LogoutWithPost` メソッドの実行中には、`p_no` が1度インクリメントされる（`getPNo()`が呼び出されるため）。
    -   ログアウト後、再度ログインすると、`p_no` は新しいセッションの開始に伴い、再び `1` にリセットされる。これは、サーバーから新しいセッションの `p_no` が提供されるためである。

-   **本番環境での再ログインの可能性**:
    -   APIのドキュメントに明確な記載はないものの、エラーメッセージ「電話認証後、3分以内にログインしてください」から推測するに、一度電話認証を完了すれば、その**3分間の有効期間内**であれば、ログアウトしても再度のログインが可能である可能性が高い。
    -   ログアウトはセッションを切断するが、「電話認証によるログイン許可状態」を直ちにリセットするものではないと考えられる。この挙動は、開発中のテストで確認する必要がある。

#### 3.7. テストにおけるインタラクティブプロンプトの運用 (2025-12-19 追記)

`go test` 環境でのインタラクティブなプロンプトの挙動について、以下の知見が得られた。

-   **`go test` とインタラクティブプロンプトの相性**:
    -   `go test` は、テストコードからの標準入力 (`bufio.NewReader(os.Stdin)`) の読み取りをうまく扱えない場合がある。特にCI/CD環境や非対話的な実行では、入力待ちにならずに即座に処理が続行され、空の入力と判断されることがある。
-   **運用方針**:
    -   このため、電話認証の確認のような**インタラクティブなプロンプトは、開発者が意図的に対話的に実行するテストファイル内（例: `price_info_client_impl_prod_test.go`）に限定すべきである。**
    -   共通のテストヘルパー関数 (`CreateTestClient`) や、CI/CDで実行される可能性のあるテストファイルには、インタラクティブなプロンプトを含めるべきではない。これにより、テストの実行環境に依存しない安定したテスト運用が可能となる。

### 4. WebSocket EVENT I/F の特殊なデータ形式と効率性 (2025-12-28 追記)

-   **課題**: WebSocket (EVENT I/F) から受信するリアルタイムイベント（注文約定通知、時価配信など）のメッセージ形式が、従来のREST API (REQUEST I/F) で使用されるJSON形式と異なっていた。
-   **原因**: 提供されたドキュメント「ｅ支店・ＡＰＩ（ｖ４ｒ７）、ブラウザからの利用方法・時価配信情報取得編」を精査した結果、EVENT I/Fは`^A` (0x01) および`^B` (0x02) という制御文字をデリミタとして使用する独自のテキストベースのキーバリュー形式であることが判明した。
    *   `^A` でキーバリューペアを区切り、`^B` でキーと値を区切る。
    *   `p_cmd` フィールドがイベントの種類（例: `FD` = 時価配信、`ST` = ステータス通知）を識別する役割を果たす。
-   **ノウハウ**:
    -   リアルタイムで大量の時価情報などを配信するEVENT I/Fにおいて、JSON形式の冗長性を排除し、データサイズを削減することで、通信量と処理負荷を低減するパフォーマンス重視の設計思想であると推測される。
    -   この独自形式を処理するためには、`bytes.Split`などのGoの標準機能を用いて手動でメッセージをパースする専用のパーサーを実装する必要がある。従来のJSONデコード処理は適用できない。
    -   12/30の接続テストでは、`p_cmd`の具体的な値や各イベントのデータ項目名と内容を正確に把握することが極めて重要となる。