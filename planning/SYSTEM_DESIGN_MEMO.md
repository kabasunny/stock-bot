# システム設計に関する検討事項

## 本ドキュメントの歩き方と運用ルール

本ドキュメントは、プロジェクトの全体像、現在のアーキテクチャ、主要な決定事項、未解決の課題、開発標準手順、そして直近の進捗と次のアクションプランを示す「要約」です。

過去の詳細な開発経緯やデバッグの記録は、**`@planning/DEVELOPMENT_LOG.md`** に時系列で記載されています。

### 作業開始時の確認フロー

1.  **最初にここを見る**:
    まず、このファイル (`SYSTEM_DESIGN_MEMO.md`) の **`次回のアクションプラン`** セクションを確認してください。これが現在の最優先タスクリストです。

2.  **背景を理解する**:
    アクションプランの背景を理解するために、同ファイルの **`実装から得られた知見`** を確認します。最新の開発進捗については `DEVELOPMENT_LOG.md` の先頭を参照してください。

3.  **過去に遡る**:
    さらに詳細な経緯や過去の意思決定について知りたい場合は、**`@planning/DEVELOPMENT_LOG.md`** を参照してください。

### `DEVELOPMENT_LOG.md` の更新タイミング

`DEVELOPMENT_LOG.md` は、大きなタスクや課題が解決するたびに更新します。

1.  **タスク完了と進捗追記**:
    `SYSTEM_DESIGN_MEMO.md` の「次回のアクションプラン」に記載されたタスクを完了させ、その結果を新しい「開発進捗」として記載する準備をします。
2.  **古い進捗の移動**:
    次の「アクションプラン」へ移るタイミングで、**完了したタスクに関する一つ前の「開発進捗」の記述**を `SYSTEM_DESIGN_MEMO.md` から切り取り、`DEVELOPMENT_LOG.md` の**先頭（最新のログが一番上）**へ移動させます。

このルールにより、`SYSTEM_DESIGN_MEMO.md` は常に「今とこれから」に焦点を当てた要約であり続け、`DEVELOPMENT_LOG.md` は時系列の完全な開発記録となります。

### 「実装から得られた知見」セクションの運用

このセクションは、開発中に得られた重要なノウハウやAPIの仕様など、**現在頻繁に参照する必要がある知見**を記録する場所です。

*   **定期的な見直し**: プロジェクトのフェーズが進むにつれて、一部の知見は「当たり前のこと」になったり、参照頻度が低下したりします。陳腐化した情報や詳細すぎる情報は、定期的に **`@planning/DEVELOPMENT_LOG.md`** に移動させます。
*   **要約を心がける**: 新しい知見を追記する際は、結論と要点を簡潔に記述します。詳細な経緯や試行錯誤の記録は、`@planning/DEVELOPMENT_LOG.md` に記載します。

このルールにより、`SYSTEM_DESIGN_MEMO.md` は常に最新かつ重要な情報へのクイックリファレンスとして機能します。

---

## 1. はじめに

本ドキュメントは、株式自動取引システムのアーキテクチャを具体化するにあたり、検討すべき主要な論点を整理することを目的とします。
*(2025-12-06 追記: 当初の設計から議論を経て、より責務が明確な「エージェント中心」のアーキテクチャへと方針を更新した。以降の章は、この新しい方針を反映している。)*

## 2. 基本アーキテクチャ方針 (エージェント中心モデル)
システムは、責務が明確に分離された以下の3つのコンポーネントで構成される。

1.  **Go製 APIラッパー (Go API Wrapper)**
    -   **役割**: 証券会社APIとの直接的な通信（REST, WebSocket）をすべて担当し、その複雑さを抽象化する。
    -   **機能**: 外部からのHTTPリクエストに基づき、データ取得、注文執行などを行う。Goaフレームワークを用いて、堅牢なHTTP APIを公開する。
    -   https://github.com/e-shiten-jp?tab=repositories ここに参考のPythonコードがあるので、リクエストを作成する際の参考にする

2.  **Python製 シグナル生成サービス (Python Signal Generator)**
    -   **役割**: 高度な計算や機械学習モデルを用いて、売買シグナルを生成することに特化する。
    -   **機能**: 外部から市場データを受け取り、分析結果のシグナルを返すHTTP APIを公開する。自らは動かない受動的なコンポーネント。

3.  **エージェント (Agent)**
    -   **役割**: システム全体の「頭脳」であり、主体的な意思決定を行う中央司令塔。
    -   **機能**: 取引戦略のメインループとして、Go APIラッパー（データ取得/注文）とPythonサービス（シグナル問合せ）を呼び出し、全体のワークフローを指揮する。

## 3. 主要なワークフロー
すべてのワークフローは「エージェント」が起点となる。

1.  **エージェント**: データ取得のため **Go APIラッパー** を呼び出す。
2.  **Go APIラッパー**: 証券会社APIからデータを取得し、エージェントに返却する。
3.  **エージェント**: 受け取ったデータを **Pythonサービス** に渡し、売買シグナルを問い合わせる。
4.  **Pythonサービス**: データ分析を行い、シグナルをエージェントに返却する。
5.  **エージェント**: シグナルと自身のロジックに基づき売買を判断し、**Go APIラッパー** を呼び出して発注を指示する。

## 4. 実装計画と技術選択

### 4.1. 短期計画: Goによるモノリシックな実装
まず、迅速にプロトタイプを構築するため、**Go APIラッパー**と**エージェント**を単一のGoアプリケーション内のコンポーネントとして実装する。
- コンポーネント間の通信は、Goaで定義したHTTP APIを通じて行う (`localhost`経由)。これは将来的なサービス分割（次項）を見据えた疎結合な設計のためである。

### 4.2. 長期目標: エージェントのRust化
システムの安定稼働後、さらなるパフォーマンスと安全性を追求するため、**エージェントをRust製のマイクロサービスとして再実装し、独立させる**ことを最終目標とする。
- 初期段階で通信をHTTP APIに定めているため、Go製エージェNTをRust製エージェントに置き換える作業は、比較的スムーズに行える。

## 5. 実装に向けた主要な検討事項 (Issue)
*(このセクションは、新しいアーキテクチャの観点から再構成)*

### Issue 1: リアルタイムイベントの受信方式の特定 (変更なし)
-   **論点**: 利用する証券会社APIは、リアルタイムの株価情報や約定通知などをどのような形式で提供しているか？ (WebSocket, etc.)
-   **重要性**: Go APIラッパーの`EventClient`の実装方法に大きく影響する。

### Issue 2: コンポーネント間連携インターフェース設計 (更新)
-   **論点**: エージェント、Go APIラッパー、PythonサービスはそれぞれHTTP APIを介して通信する。Go APIラッパーのAPI設計にはGoaフレームワークを採用する。
-   **データ形式**: 連携時のデータ形式はJSONとする。

*(旧Issue 3, 4は新アーキテクチャにおいて責務が明確化されたため解消)*

---

### 開発標準手順

### リファクタリング標準手順 (2025-12-09 追記)
レイヤー間の責務移動など、アーキテクチャの健全性を維持するためのリファクタリングは、以下の手順書に従って実施する。
- **`planning/REFACTORING_PROCEDURE.md`**

### 共通操作におけるユーザーとの連携方針

プロジェクトのビルド、アプリケーションサーバーの起動、および `curl` コマンドなどによるAPIエンドポイントのテストといった、システムの状態を変更したり、外部との連携を伴う共通操作については、以下の原則に基づきユーザーに実行を依頼する。

-   **ビルド操作**: `go build` 等のビルドコマンド。
-   **アプリケーションサーバーの起動**: `go run` やコンパイル済みバイナリの実行など。
-   **外部連携コマンド**: `curl`, `Invoke-WebRequest` など、APIエンドポイントへのリクエスト送信。

これは、ユーザー環境への影響を最小限に抑え、各ステップにおいてユーザーの明示的な承認を得るためのものである。

### Goaサービス実装の標準手順 (2025-12-07 追記)

GoaでAPIサービスを実装する際の標準的な手順を以下に定める。これは、テスト駆動開発(TDD)のアプローチを取り入れ、堅牢なシステム構築を目指すものである。すべてのGoaサービス実装において、この手順に統一して開発を進めること。

**ゴール**: 特定のAPIエンドポイントが、クライアントから受け取った情報に基づき、インフラ層のクライアントを呼び出し、必要な処理を実行して、その結果を返す。

**前提**: Goaの設計ファイル (`design/design.go`) にAPI定義が完了しており、`goa gen` によってコードが自動生成されていること。また、インフラ層の外部APIクライアントは単体テストが完了していること。

#### ステップ1: ユースケースの「振る舞い」をテストで定義する (TDD)
目的: `UseCase` が持つべき振る舞いをテストで定義する。

1.  **テストファイル作成**: `internal/app/<service_name>_usecase_impl_test.go` を新規作成。
2.  **テスト内容**:
    *   モック（例: `OrderRepository`, `TachibanaOrderClient`）を準備し、`UseCase` が依存するコンポーネントが期待通りに呼び出されることを検証する。
    *   成功ケース、失敗ケース、バリデーションエラーなど、主要なシナリオに対するテストケースを記述する。
3.  **実行**: `go test ./internal/app/...` を実行。テストはコンパイルエラーまたは失敗するはず。これが、次の実装の明確なゴールとなる。

#### ステップ2: テストをパスさせるユースケースを実装する
目的: ステップ1で書いたテストをパスさせる。

1.  **実装ファイル作成**: `internal/app/<service_name>_usecase_impl.go` を新規作成。
2.  **実装内容**:
    *   `<Service>UseCaseImpl` 構造体を定義し、依存する `Repository` や `Client` をフィールドに持つ。
    *   `Execute<Service>` メソッド（または対応するメソッド）を実装する。この中で、インフラ層のクライアントを呼び出し、ビジネスロジックを実行する。
3.  **実行**: `go test ./internal/app/...` を実行し、**ステップ1のテストがすべてパスする**まで実装を修正する。

#### ステップ3: アプリケーション起動時の依存性注入 (DI)
目的: アプリケーション起動時に、各コンポーネントを正しく組み立てる。

1.  **ファイル修正**: `cmd/myapp/main.go` を修正。
2.  **実装内容**:
    *   インフラ層のクライアント、リポジトリのインスタンスを作成。
    *   上記を `New<Service>UseCaseImpl` に渡して `UseCase` のインスタンスを作成。
    *   作成した `UseCase` を `web.New<Service>Service` に渡して `Service` (ハンドラ) のインスタンスを作成。
    *   Goaサーバーに `Service` を登録する。
3.  **実行**: `go run ./cmd/myapp/main.go` を実行し、コンパイルエラーや起動時エラーが出ないことを確認する。

#### ステップ4: ハンドラとユースケースのつなぎこみ
目的: APIハンドラから、DIされたユースケースを呼び出す。

1.  **ファイル修正**: `internal/handler/web/<service_name>_service.go` を修正。
2.  **実装内容**:
    *   Goaの `Payload` を `app.Params` に変換する。
    *   `s.usecase.Execute<Service>(...)` を呼び出す。
    *   結果をGoaの `Result` に変換して返す。

#### ステップ5: 統合テスト
目的: APIエンドポイントを実際に呼び出し、システム全体が正しく連携して動作することを確認する。

1.  **実行**:
    1.  `go run ./cmd/myapp/main.go` でサーバーを起動。
    2.  `curl` などのツールで対象のAPIエンドポイントを呼び出す。
2.  **確認**:
    *   期待通りのHTTPステータスコードとレスポンスボディが返ってくること。
    *   (必要に応じて) データベースや外部システムのログなどで、処理が正しく行われたことを確認する。



Invoke-WebRequest -Uri http://localhost:8080/order -Method POST  -Headers @{"Content-Type"="application/json"} -Body '{"symbol":"6658","trade_type":"BUY","order_type":"MARKET","quantity":100}'

---

## 開発進捗（2025-12-20）

### ログイン仕様のテストと明確化
APIのログイン仕様に関する不明点を解消するため、`planning/LOGIN_TEST_PLAN.md`を作成し、体系的なテスト計画を立案した。
`TEST-001`（連続ログイン）および`TEST-002`（時間差ログイン）を実行し、以下の重要な仕様を特定した。

1.  **電話認証の有効期間**: 手動での電話認証後、実際にログインリクエストが成功するまでの有効期間は**約3分**であることを確認した。
2.  **セッションの独立性**: ログインに成功するたびに、サーバーは新しい独立したセッションを確立する。

### APIクライアントのリファクタリング: セッションオブジェクトの導入
上記テスト結果と、より高度なセッションテストの必要性から、クライアントからセッション状態を分離する大規模なリファクタリングを実施した。

**本日完了した作業:**
*   **`Session`構造体の定義**: ログイン情報をカプセル化する`Session`構造体を`session.go`に作成。
*   **クライアントのステートレス化**: `TachibanaClientImpl`からセッション状態（ログイン情報、p_no等）を削除し、`sUserId`, `sPassword`などログインに必要な初期設定のみを残すように修正。
*   **インターフェースの更新**: `AuthClient`, `PriceInfoClient`, `OrderClient`, `BalanceClient`, `MasterDataClient`の全メソッドのシグネチャを、`Session`オブジェクトを利用する形に更新。
*   **実装の更新**: 上記インターフェース変更に伴い、`DownloadMasterData`を除く全ての`...ClientImpl`の実装を修正。

---

#### 次回のアクションプラン

**最優先タスク: APIクライアントのリファクタリングの完了**

1.  **`DownloadMasterData`メソッドの修正**:
    *   **内容**: 特殊なストリーミング処理を持つ`DownloadMasterData`メソッドを、`Session`オブジェクトを利用するように修正します。
    *   **目的**: APIクライアントのリファクタリングを継続し、全てのAPI呼び出しで新しいセッション管理モデルを適用します。

2.  **テストコードの全面的な修正**:
    *   **内容**: 今回のリファクタリングで変更されたすべてのインターフェースと実装に合わせて、関連するテストコード（`auth_client_impl_test.go`など）を修正します。
    *   **目的**: システム全体の動作を保証します。

---

## 実装から得られた知見（APIクライアント編）

本セクションでは、開発過程で遭遇した立花証券APIの特殊な仕様や、それに対する実装上のノウハウを記録する。

### 1. APIの環境差異とURLのバージョン管理

- **課題**: テスト環境とローカル環境で同じコードにも関わらず、ローカルでのみログインAPIが404エラーを返した。
- **原因**: APIのベースURLにバージョン情報（例: `v4r8`）が含まれており、ローカルの`.env`ファイルに設定されたURLのバージョンが古かった (`v4r7`)。
- **ノウハウ**:
    - APIへの接続テストが失敗する場合、コードのロジックだけでなく、`.env`ファイルに設定されたエンドポイントURL (`TACHIBANA_BASE_URL`など) が、テスト対象の環境で有効なものであるかを最初に確認する必要がある。
    - APIのバージョンアップに伴い、URLも変更される可能性があることを常に念頭に置く。

### 2. マスターデータ取得APIの特殊なストリーミング仕様

- **課題**: 全件マスターデータを取得する`DownloadMasterData` APIを呼び出すと、`bufio.Scanner: token too long`エラーが発生し、ストリームを最後まで読み取れなかった。
- **原因**: このAPIは、数万行に及ぶデータを、**改行なしの単一の巨大なライン、あるいは連続したJSONオブジェクト**としてストリーミング配信する特殊な仕様となっている。Go標準ライブラリの`bufio.Scanner`は改行をデリミтаとしており、この形式に対応できない。
- **解決策**: 公式のPythonサンプルコードのロジックを参考に、以下の手動パーシング処理を実装した。
    1. レスポンスボディを固定長のチャンク（例: 4096バイト）で読み込む。
    2. 読み込んだバイト列を一時的なバッファ (`bytes.Buffer`) に蓄積する。
    3. バッファ内にJSONオブジェクトの終端文字 (`}`) が存在するかを検索する。
    4. 終端文字が見つかった場合、そこまでを一つのJSONオブジェクト候補として切り出し、`json.Unmarshal`でデコードを試みる。
    5. デコードが成功した場合、バッファからその部分を削除し、次のオブジェクトの処理に移る。
    6. これを、APIから`CLMEventDownloadComplete`という完了通知オブジェクトが送られてくるまで繰り返す。
- **ノウハウ**:
    - ストリーミングAPIを扱う際は、データがどのような形式・区切り文字で送られてくるかを正確に把握することが極めて重要である。
    - 標準ライブラリで対応できない特殊な形式の場合、公式のサンプルコード（もしあれば）の挙動を模倣した、より低レベルなバイト/チャンク処理の実装が必要となる。

### 3. 認証とテスト環境の仕様 (2025-12-16 追記)

#### 3.1. 本番環境の二要素認証 (2FA)

- **課題**: 本番環境に対してログインAPIを実行すると、`result code 10088: 当社に登録の電話番号から認証電話番号へかけた後にログインしてください。` というエラーで失敗する。
- **原因**: 本番環境のAPIは、セキュリティ強化のため、ID/パスワード認証に加えて電話認証を要求する。具体的には、ログインリクエストを送信する**前**に、予め登録した電話番号から指定の認証用番号へ電話を発信する必要がある。
- **ノウハウ**:
    - **機能開始日時**: 2025年7月26日（土）システムメンテナンス終了以降
    - **API用認証電話番号**: 0120-28-6592 または 050-3102-6575（通話料有料）
    - この仕様のため、テストコードやCI/CDパイプライン内での完全自動ログインは不可能である。
    - 本番環境に対するテスト（データ取得など）を実行するには、以下の手動ステップが必要になる。
        1.  開発者が手動で電話認証を行い、`curl` などでログインを実行する。
        2.  成功したレスポンスから、後続のリクエストに必要なセッション情報（Cookie, 各種URL, `p_no`など）を抽出する。
        3.  抽出した情報を環境変数などを介してテストプログラムに渡し、ログイン済みの状態を擬似的に再現する。
    - **(2025-12-20 追記)** 電話認証の有効期間は**約3分**。この時間を超過すると`result code 10089`エラーでログインに失敗する。

#### 3.2. デモ環境のデータ制限

- **課題**: デモ環境に対して`GetPriceInfo`（株価照会）や`GetPriceInfoHistory`（時価履歴）などのAPIを実行すると、エラーにはならないが、レスポンスのデータ部分が空の配列で返ってくる。
- **原因**: APIの公式ドキュメントおよび実際の挙動から、デモ環境はAPIの接続性やリクエスト形式の検証を目的としており、リアルな株価データや履歴データを返却しない仕様であることが確認された。
- **ノウハウ**:
    - デモ環境を対象とするテストは、データが空で返ってくることを前提に実装する必要がある。
    - テストコード内では、レスポンスのデータ配列の長さが0より大きいか (`len(data) > 0`) を確認した上で、データ内容のアサーションを行うべきである。これにより、同じテストコードで、デモ環境では接続性の確認、本番環境ではデータ内容の正当性検証、という両方の役割を担うことができる。

#### 3.3. Cookieベースのセッション管理

- **課題**: ログイン後のセッションをどのように維持し、後続のリクエストで認証済み状態を伝えるか。
- **原因**: 多くのAPIで採用されている`Authorization`ヘッダー（Bearerトークンなど）ではなく、このAPIは **HTTP Cookie** (`_SID`など) を用いてセッションを管理している。
- **ノウハウ**:
    - APIと通信するHTTPクライアントは、`CookieJar`を有効にして、サーバーから送られてくる`Set-Cookie`ヘッダーを適切に保存・送信する必要がある。
    - 手動で本番テストを行う際は、ログインレスポンスの`Set-Cookie`ヘッダーの値が、認証を維持するための最も重要な情報となる。
    - **(2025-12-20 追記)** ログインのたびに、サーバーは**新しい独立したセッション**を確立する。これにより、クライアント側の`p_no`は常に`1`にリセットされる。古いセッションは、新しいログインによって無効化される可能性が高い（要検証: `TEST-006`）。

#### 3.4. 認証・アカウントロック時のエラーコードに関するドキュメントの不足 (2025-12-18 追記)

- **課題**: API利用における認証失敗時やアカウントロック状態に陥った際の、具体的なエラーコードやレスポンス形式に関する情報が不足している。
- **調査**: 公式の日本株APIリファレンスマニュアル (`https://www.e-shiten.jp/e_api/mfds_json_api_refference.html`) を確認したが、「電話認証前のエラー」や「アカウントロック状態」を示す具体的なエラーコードや詳細な記述は見当たらなかった。
- **ノウハウ**:
    - エラーハンドリングを実装する際は、エラーコードのみに依存せず、`ResultText`などのメッセージ内容やHTTPステータスコードを複合的に判断する必要がある。
    - また、APIからのレスポンスを詳細にログに記録し、実際の挙動からエラーパターンを特定する運用が必要となる。

#### 3.5. 認証に関するサポートからの回答 (2025-12-19 追記)

APIアカウントロック問題（`2025-12-17`）を受け、証券会社サポートに確認した結果、以下の仕様が判明した。これは、特に本番環境でのエージェントの安定稼働を設計する上で重要な制約となる。

-   **ログイン失敗カウントの分離**:
    -   デモ環境のログインAPIでの失敗は、デモ環境内でのみカウントされ、本番環境の失敗カウントには加算されない。これにより、デモ環境での認証関連テストは、本番アカウントのロックを心配せず実施できる。

-   **アカウントロックポリシーの非開示**:
    -   本番環境でアカウントロックに至るログイン失敗の正確な回数は**非開示**である。
    -   このため、本番環境でのログイン処理に自動リトライを組み込むことは、意図せずアカウントをロックさせる高いリスクを伴う。ログイン失敗時の処理は、即時通知と手動介入を基本方針とすべきである。

-   **ロック解除プロセス**:
    -   APIアクセスが原因でアカウントがロックされた場合、解除には**サポートセンターへの電話連絡が必須**となる。自動化された解除手段は存在しない。

-   **API利用可能時間帯**:
    -   APIサーバーは、データ更新のため毎日**午前3:30～5:30頃**にシステム停止する。これに伴い、電話認証やAPIセッションの開始も、この停止時間が終了した後から可能となる。エージェントの起動・再接続シーケンスは、この時間帯を考慮して設計する必要がある。

#### 3.6. ログイン/ログアウト時のP_no挙動と再ログインの可能性 (2025-12-19 追記)

実験とテストの結果、`p_no` および本番環境での再ログインについて以下の知見が得られた。

-   **`p_no` の挙動**:
    -   クライアントの `p_no` は、ログイン成功時にAPIからのレスポンスに含まれる値で初期化される。通常、最初のログイン成功時には `1` が設定される。
    -   `Logout` および `LogoutWithPost` メソッドの実行中には、`p_no` が1度インクリメントされる（`getPNo()`が呼び出されるため）。
    -   ログアウト後、再度ログインすると、`p_no` は新しいセッションの開始に伴い、再び `1` にリセットされる。これは、サーバーから新しいセッションの `p_no` が提供されるためである。

-   **本番環境での再ログインの可能性**:
    -   APIのドキュメントに明確な記載はないものの、エラーメッセージ「電話認証後、3分以内にログインしてください」から推測するに、一度電話認証を完了すれば、その**3分間の有効期間内**であれば、ログアウトしても再度のログインが可能である可能性が高い。
    -   ログアウトはセッションを切断するが、「電話認証によるログイン許可状態」を直ちにリセットするものではないと考えられる。この挙動は、開発中のテストで確認する必要がある。

#### 3.7. テストにおけるインタラクティブプロンプトの運用 (2025-12-19 追記)

`go test` 環境でのインタラクティブなプロンプトの挙動について、以下の知見が得られた。

-   **`go test` とインタラクティブプロンプトの相性**:
    -   `go test` は、テストコードからの標準入力 (`bufio.NewReader(os.Stdin)`) の読み取りをうまく扱えない場合がある。特にCI/CD環境や非対話的な実行では、入力待ちにならずに即座に処理が続行され、空の入力と判断されることがある。
-   **運用方針**:
    -   このため、電話認証の確認のような**インタラクティブなプロンプトは、開発者が意図的に対話的に実行するテストファイル内（例: `price_info_client_impl_prod_test.go`）に限定すべきである。**
    -   共通のテストヘルパー関数 (`CreateTestClient`) や、CI/CDで実行される可能性のあるテストファイルには、インタラクティブなプロンプトを含めるべきではない。これにより、テストの実行環境に依存しない安定したテスト運用が可能となる。


