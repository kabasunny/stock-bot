# システム設計に関する検討事項

## 1. はじめに

本ドキュメントは、株式自動取引システムのアーキテクチャを具体化するにあたり、検討すべき主要な論点を整理することを目的とします。
*(2025-12-06 追記: 当初の設計から議論を経て、より責務が明確な「エージェント中心」のアーキテクチャへと方針を更新した。以降の章は、この新しい方針を反映している。)*

## 2. 基本アーキテクチャ方針 (エージェント中心モデル)
システムは、責務が明確に分離された以下の3つのコンポーネントで構成される。

1.  **Go製 APIラッパー (Go API Wrapper)**
    -   **役割**: 証券会社APIとの直接的な通信（REST, WebSocket）をすべて担当し、その複雑さを抽象化する。
    -   **機能**: 外部からのHTTPリクエストに基づき、データ取得、注文執行などを行う。Goaフレームワークを用いて、堅牢なHTTP APIを公開する。

2.  **Python製 シグナル生成サービス (Python Signal Generator)**
    -   **役割**: 高度な計算や機械学習モデルを用いて、売買シグナルを生成することに特化する。
    -   **機能**: 外部から市場データを受け取り、分析結果のシグナルを返すHTTP APIを公開する。自らは動かない受動的なコンポーネント。

3.  **エージェント (Agent)**
    -   **役割**: システム全体の「頭脳」であり、主体的な意思決定を行う中央司令塔。
    -   **機能**: 取引戦略のメインループとして、Go APIラッパー（データ取得/注文）とPythonサービス（シグナル問合せ）を呼び出し、全体のワークフローを指揮する。

## 3. 主要なワークフロー
すべてのワークフローは「エージェント」が起点となる。

1.  **エージェント**: データ取得のため **Go APIラッパー** を呼び出す。
2.  **Go APIラッパー**: 証券会社APIからデータを取得し、エージェントに返却する。
3.  **エージェント**: 受け取ったデータを **Pythonサービス** に渡し、売買シグナルを問い合わせる。
4.  **Pythonサービス**: データ分析を行い、シグナルをエージェントに返却する。
5.  **エージェント**: シグナルと自身のロジックに基づき売買を判断し、**Go APIラッパー** を呼び出して発注を指示する。

## 4. 実装計画と技術選択

### 4.1. 短期計画: Goによるモノリシックな実装
まず、迅速にプロトタイプを構築するため、**Go APIラッパー**と**エージェント**を単一のGoアプリケーション内のコンポーネントとして実装する。
- コンポーネント間の通信は、Goaで定義したHTTP APIを通じて行う (`localhost`経由)。これは将来的なサービス分割（次項）を見据えた疎結合な設計のためである。

### 4.2. 長期目標: エージェントのRust化
システムの安定稼働後、さらなるパフォーマンスと安全性を追求するため、**エージェントをRust製のマイクロサービスとして再実装し、独立させる**ことを最終目標とする。
- 初期段階で通信をHTTP APIに定めているため、Go製エージェNTをRust製エージェントに置き換える作業は、比較的スムーズに行える。

## 5. 実装に向けた主要な検討事項 (Issue)
*(このセクションは、新しいアーキテクチャの観点から再構成)*

### Issue 1: リアルタイムイベントの受信方式の特定 (変更なし)
-   **論点**: 利用する証券会社APIは、リアルタイムの株価情報や約定通知などをどのような形式で提供しているか？ (WebSocket, etc.)
-   **重要性**: Go APIラッパーの`EventClient`の実装方法に大きく影響する。

### Issue 2: コンポーネント間連携インターフェース設計 (更新)
-   **論点**: エージェント、Go APIラッパー、PythonサービスはそれぞれHTTP APIを介して通信する。Go APIラッパーのAPI設計にはGoaフレームワークを採用する。
-   **データ形式**: 連携時のデータ形式はJSONとする。

*(旧Issue 3, 4は新アーキテクチャにおいて責務が明確化されたため解消)*

## 6. 調査と決定事項 (2025-12-02)

### Issue 1: リアルタイムイベントの受信方式の特定
-   **調査**: 立花証券APIのドキュメントおよび公式GitHubリポジトリ(`e-shiten-jp/e_api_websocket_receive_tel.py`)のサンプルコードを調査・解析した。
-   **結論**: APIはリアルタイム配信用に **WebSocket (`EVENT I/F`)** を提供している。リアルタイム性と効率性を考慮し、本システムではこのWebSocket方式を採用する。

#### WebSocket (`EVENT I/F`) の仕様
-   **接続URL**:
    1.  通常のログインAPI(`auth_client`)を呼び出し、認証を行う。
    2.  レスポンスに含まれるWebSocket専用の **仮想URL (`sUrlEventWebSocket`)** を取得する。
    3.  この仮想URLに対し、購読したい銘柄コードや情報種別(`p_evt_cmd=FD`等)をクエリパラメータとして付加し、接続する。
-   **データ形式**:
    -   一般的なJSONではなく、**特殊な制御文字で区切られた独自のテキスト形式**である。
    -   `\x01` (`^A`): 項目全体の区切り
    -   `\x02` (`^B`): 項目名と値の区切り
    -   `\x03` (`^C`): 項目内で複数の値を区切る
    -   この仕様に基づき、Go側で専用のパーサーを実装する必要がある。

### Issue 2: Go-Python間の連携インターフェース設計
-   **方針**: 上記WebSocketの採用に伴い、シグナル系統の連携方式を具体化する。
-   **Go -> Python**: GoのWebSocketクライアントがリアルタイムデータを受信する都度、パース処理を行い、案2の通りPython側のWeb APIエンドポイント (例: `POST /api/signal`) へHTTP POSTでプッシュ通知する。
-   **Python -> Go**: 従来の方針通り、Go側で注文受付用のHTTP API (例: `POST /api/order`) を用意する。

### 次のアクション: GoによるWebSocketクライアントの実装
上記方針に基づき、Go側で `EVENT I/F` をハンドリングするクライアントの実装に着手する。

1.  **ファイル作成**:
    *   `internal/infrastructure/client/event_client.go` (インターフェース)
    *   `internal/infrastructure/client/event_client_impl.go` (実装)
2.  **接続処理の実装**: ログイン機能と連携し、取得した仮想URLを使ってWebSocketサーバーに接続する処理を実装する。
3.  **パーサーの実装**: 受信した独自形式のメッセージを制御文字で分割・解析し、Goのデータ構造（`map`や`struct`）に変換するパーサーを実装する。
4.  **イベントループの実装**: サーバーから継続的にメッセージを受信し、パーサーを通して処理するイベントループを実装する。
5.  **アプリケーションへの統合**: 実装したクライアントをアプリケーション全体に組み込み、受信データを後続処理（Pythonへの通知など）へ連携させる。

### 開発進捗 (2025-12-02)

#### Issue 1: リアルタイムイベントの受信方式の特定 (進捗)
-   GoによるWebSocketクライアント (`EventClient`) の実装に着手し、`event_client.go` および `event_client_impl.go` を作成した。
-   WebSocketメッセージの独自形式を解析するパーサー (`ParseMessage`) の単体テストは**PASS**した。
-   デモAPIへのWebSocket接続テスト (`TestEventClient_ConnectReadMessagesWithDemoAPI`) を実装したが、依然として `websocket: bad handshake` エラーで**FAIL**している。
-   これまでに `Origin` ヘッダーと `User-Agent` ヘッダーの追加を試みたが、エラーは解消されていない。

#### 次のステップ (2025-12-03 以降)
-   引き続き `websocket: bad handshake` エラーの原因を詳細に調査する。APIドキュメントの再確認、Pythonサンプルコードのより深い分析、または`gorilla/websocket`とAPIサーバー間の通信プロトコルの詳細な比較が必要となる可能性がある。

### 開発進捗 (2025-12-03)

#### `websocket: bad handshake` エラーの深掘り調査

-   **問題**: `Subprotocol`ヘッダーを追加後も、依然として `websocket: bad handshake` エラーが解消しない。
-   **仮説1: 認証Cookieの欠落**:
    -   **調査**: 公式PythonサンプルおよびGoの参考実装(`tsuchinaga/go-tachibana-e-api`)を再度調査。ログイン時に取得した認証情報(`Cookie`)が、後続のWebSocketハンドシェイクリクエストに含まれていないことが原因である可能性が高いと判断。
    -   **修正**: `TachibanaClientImpl`が`CookieJar`を持つ共有の`http.Client`インスタンスを一元管理するよう、大規模なリファクタリングを実施。
        1.  `tachibana_client.go`: `TachibanaClientImpl`に`httpClient *http.Client`フィールドを追加し、`NewTachibanaClient`で`CookieJar`と共に初期化するよう修正。
        2.  `util.go`: `SendRequest`, `SendPostRequest`が、引数で渡された共有`http.Client`インスタンスを使用するよう修正。
        3.  `auth_client_impl.go`, `balance_client_impl.go`, `master_data_client_impl.go`, `order_client_impl.go`, `price_info_client_impl.go`: `SendRequest`等の呼び出し時に、共有`httpClient`を渡すよう全ファイルを修正。
        4.  `event_client_impl.go`: WebSocket接続時に`CookieJar`を`websocket.Dialer`に設定するよう修正。
-   **仮説2: `Origin`ヘッダーの形式不備**:
    -   **調査**: 上記修正後もエラーが解消せず。公式Pythonサンプルの`Origin`ヘッダーがパス情報を含まない (`https://<hostname>`) のに対し、こちらの実装ではパス情報まで含めてしまっている (`https://<hostname>/<path>`) ことを発見。これが原因である可能性を特定。
    -   **修正**: `event_client_impl.go`を修正し、`Origin`ヘッダーが`scheme`と`host`のみで構成されるよう修正。
-   **結果**: 上記2つの仮説に基づき大規模な修正を行ったが、テスト結果は変わらず `websocket: bad handshake` エラーが継続。

#### 新たな可能性と今後のアクション

-   **新たな可能性（API稼働時間）**: ユーザーからの指摘により、エラーの根本原因が技術的な問題ではなく、**APIの稼働時間（取引時間外）**である可能性が浮上した。リアルタイムAPIは、市場が閉まっている時間帯には接続を拒否する仕様であることが多い。
-   **次のアクションプラン**:
    1.  **最優先事項**: 平日の取引時間中（例: 9:00〜15:00 JST）に、現在のコードのまま再度テスト(`TestEventClient_ConnectReadMessagesWithDemoAPI`)を実行し、接続が成功するかどうかを確認する。
    2.  **次善手（取引時間中でも失敗した場合）**: もし取引時間中でも`bad handshake`エラーが解消されない場合は、原因の切り分けのため、「Cookieが本当に必要か」を再検証する。具体的には、`eventClient.Connect`に`nil`の`CookieJar`を渡してテストを実行し、挙動の変化を確認する。

### 開発進捗 (2025-12-06)

#### アーキテクチャの再定義とGoa導入
- **アーキテクチャの再定義**: 議論を経て、システム全体の設計を「エージェント中心モデル」に更新。Go APIラッパー、Pythonシグナル生成サービス、そして全体の司令塔となるエージェントの3層構造を定義した。短期計画としてエージェントをGoで実装し、長期目標としてRustへの移行を目指す方針を固めた。
- **ドキュメント更新**: 上記の新アーキテクチャに合わせて、`SYSTEM_DESIGN_MEMO.md`および`README.md`を全面的に更新した。
- **ディレクトリ構造の変更**: 新しいアーキテクチャの責務を明確にするため、`internal/interface`ディレクトリを廃止し、`internal/handler`（Webリクエスト処理層）と`internal/agent`（エージェントロジック層）に再編成した。
- **Goaフレームワーク導入**:
    1. Goaツールをインストール。
    2. APIの設計図として`design/design.go`を作成。
    3. `goa gen`コマンドでコードを自動生成。
    4. サービス実装の雛形として`internal/handler/web/order_service.go`を作成。
    5. アプリケーションのエントリーポイントとして`cmd/myapp/main.go`を作成。
- **サーバー起動とAPIテスト**:
    - 複数回にわたるコンパイルエラーのデバッグ（`import`パス、`WaitGroup`の使用法、Goaの`Logger`インターフェース、`Muxer`の`Handle`メソッドなど）を経て、`go run ./cmd/myapp/main.go`による**サーバー起動に成功**した。
    - `Invoke-WebRequest`コマンドを使用し、`POST /order`エンドポイントのテストを実施。HTTPステータス`201 Created`とダミーの注文ID `{"order_id":"order-12345"}`が返却されることを確認し、**APIが正常に動作していることを確認した**。

#### 次のアクションプラン (2025-12-07 以降)
1.  **つなぎこみ実装**: `order_service.go`のダミー処理を、実際の`OrderUsecase`を呼び出すロジックに置き換える。
2.  **WebSocket接続テスト**: `websocket: bad handshake`エラーのデバッグを、平日の取引時間中に実施する。

### 開発進捗 (2025-12-07)

#### `Order` サービスのバックエンド実装
TDD（テスト駆動開発）に基づく標準手順に沿って、`POST /order` APIのバックエンド実装を推進した。

1.  **開発標準手順の策定:**
    *   TDDに基づいたGoaサービス実装の標準手順を新たに策定し、本ドキュメントに追記した。今後、他のGoaサービスを実装する際もこの手順に統一する。

2.  **ユースケースの実装と単体テスト:**
    *   `OrderUseCase` の振る舞いを定義する単体テスト (`order_usecase_impl_test.go`) を先行して作成した。
    *   コンパイルエラーとテスト失敗を段階的に修正し、テストをすべてパスする `OrderUseCase` の実装 (`order_usecase_impl.go`) を完了させた (`go test ./internal/app/...` は `PASS`)。

3.  **依存性注入 (DI) とハンドラのつなぎこみ:**
    *   `cmd/myapp/main.go` を修正し、`OrderClient` → `OrderUseCase` → `OrderService` (ハンドラ) の依存関係を正しく注入した。
    *   `internal/handler/web/order_service.go` を修正し、APIリクエストを `OrderUseCase` に連携するようにした。

4.  **統合テストと課題の特定:**
    *   サーバーを起動し、`POST /order` API の統合テストを実施。
    *   結果、`TachibanaClient` が未ログイン状態だったため、「`not logged in`」エラーが発生することを確認。アプリケーションのライフサイクルにおけるログイン状態管理の必要性が明らかになった。

#### 次回のアクションプラン (2025-12-08 以降)

1.  **最優先: 起動時ログイン処理の実装**
    *   **対象ファイル:** `cmd/myapp/main.go`
    *   **内容:** `TachibanaClient` の初期化後、サーバーがリクエストの受付を開始する前に `tachibanaClient.Login()` を呼び出す処理を追加する。ログインに失敗した場合は、エラーをログに出力してアプリケーションを終了させる。
    *   **目的:** 「`not logged in`」エラーを解消し、統合テストを成功させる。

2.  **統合テストの再実行**
    *   上記修正後、再度 `go run ./cmd/myapp/main.go` でサーバーを起動し、`POST /order` API を呼び出して、HTTPステータス `201` が返ってくることを確認する。

3.  **新規タスクの起票: `TachibanaClient` のセッション自動管理機能の実装**
    *   アプリケーションの長期的な安定稼働のため、より堅牢なセッション管理メカニズムを実装する必要がある。
    *   **具体的な検討事項:**
        *   セッションの有効期限が切れる前の定期的な再ログイン処理。
        *   API呼び出し時に認証エラーが返された場合の、動的な再ログインとリクエストのリトライ処理。
    *   このタスクは、本件の完了後、新たなIssueとして計画・管理する。

## 開発標準手順

### リファクタリング標準手順 (2025-12-09 追記)
レイヤー間の責務移動など、アーキテクチャの健全性を維持するためのリファクタリングは、以下の手順書に従って実施する。
- **`planning/REFACTORING_PROCEDURE.md`**

### Goaサービス実装の標準手順 (2025-12-07 追記)

GoaでAPIサービスを実装する際の標準的な手順を以下に定める。これは、テスト駆動開発(TDD)のアプローチを取り入れ、堅牢なシステム構築を目指すものである。すべてのGoaサービス実装において、この手順に統一して開発を進めること。

**ゴール**: 特定のAPIエンドポイントが、クライアントから受け取った情報に基づき、インフラ層のクライアントを呼び出し、必要な処理を実行して、その結果を返す。

**前提**: Goaの設計ファイル (`design/design.go`) にAPI定義が完了しており、`goa gen` によってコードが自動生成されていること。また、インフラ層の外部APIクライアントは単体テストが完了していること。

#### ステップ1: ユースケースの「振る舞い」をテストで定義する (TDD)
目的: `UseCase` が持つべき振る舞いをテストで定義する。

1.  **テストファイル作成**: `internal/app/<service_name>_usecase_impl_test.go` を新規作成。
2.  **テスト内容**:
    *   モック（例: `OrderRepository`, `TachibanaOrderClient`）を準備し、`UseCase` が依存するコンポーネントが期待通りに呼び出されることを検証する。
    *   成功ケース、失敗ケース、バリデーションエラーなど、主要なシナリオに対するテストケースを記述する。
3.  **実行**: `go test ./internal/app/...` を実行。テストはコンパイルエラーまたは失敗するはず。これが、次の実装の明確なゴールとなる。

#### ステップ2: テストをパスさせるユースケースを実装する
目的: ステップ1で書いたテストをパスさせる。

1.  **実装ファイル作成**: `internal/app/<service_name>_usecase_impl.go` を新規作成。
2.  **実装内容**:
    *   `<Service>UseCaseImpl` 構造体を定義し、依存する `Repository` や `Client` をフィールドに持つ。
    *   `Execute<Service>` メソッド（または対応するメソッド）を実装する。この中で、インフラ層のクライアントを呼び出し、ビジネスロジックを実行する。
3.  **実行**: `go test ./internal/app/...` を実行し、**ステップ1のテストがすべてパスする**まで実装を修正する。

#### ステップ3: アプリケーション起動時の依存性注入 (DI)
目的: アプリケーション起動時に、各コンポーネントを正しく組み立てる。

1.  **ファイル修正**: `cmd/myapp/main.go` を修正。
2.  **実装内容**:
    *   インフラ層のクライアント、リポジトリのインスタンスを作成。
    *   上記を `New<Service>UseCaseImpl` に渡して `UseCase` のインスタンスを作成。
    *   作成した `UseCase` を `web.New<Service>Service` に渡して `Service` (ハンドラ) のインスタンスを作成。
    *   Goaサーバーに `Service` を登録する。
3.  **実行**: `go run ./cmd/myapp/main.go` を実行し、コンパイルエラーや起動時エラーが出ないことを確認する。

#### ステップ4: ハンドラとユースケースのつなぎこみ
目的: APIハンドラから、DIされたユースケースを呼び出す。

1.  **ファイル修正**: `internal/handler/web/<service_name>_service.go` を修正。
2.  **実装内容**:
    *   Goaの `Payload` を `app.Params` に変換する。
    *   `s.usecase.Execute<Service>(...)` を呼び出す。
    *   結果をGoaの `Result` に変換して返す。

#### ステップ5: 統合テスト
目的: APIエンドポイントを実際に呼び出し、システム全体が正しく連携して動作することを確認する。

1.  **実行**:
    1.  `go run ./cmd/myapp/main.go` でサーバーを起動。
    2.  `curl` などのツールで対象のAPIエンドポイントを呼び出す。
2.  **確認**:
    *   期待通りのHTTPステータスコードとレスポンスボディが返ってくること。
    *   (必要に応じて) データベースや外部システムのログなどで、処理が正しく行われたことを確認する。



Invoke-WebRequest -Uri http://localhost:8080/order -Method POST  -Headers @{"Content-Type"="application/json"} -Body '{"symbol":"6658","trade_type":"BUY","order_type":"MARKET","quantity":100}'

### 開発進捗 (2025-12-08)

#### `POST /order` APIの統合テスト成功とデバッグの軌跡
`not logged in`エラーの解消から始まり、`order failed with result code : `という500エラーの解決まで、段階的なデバッグを経て`POST /order` APIの統合テストを成功させた。

1.  **起動時ログイン処理の実装:**
    *   `main.go`に`tachibanaClient.Login()`を呼び出す処理を追加し、「`not logged in`」エラーを解消。
    *   `config.Config`のフィールド名（`UserID` -> `TachibanaUserID`）の不整合を修正し、ログイン処理を正常に完了させた。

2.  **注文API (500エラー) のデバッグ:**
    *   `order_client_impl_neworder_test.go`が成功することから、APIサーバー経由のリクエストとテストのリクエスト内容の差異を調査。
    *   **原因1 (SecondPasswordの欠落):** `order_usecase_impl.go`で第二パスワードが設定されていなかったため、テストコードに倣いログインパスワードを渡すように修正。しかし、エラーは解消しなかった。
    *   **原因2 (必須フィールドの不足):** さらに比較した結果、逆指値関連の複数のフィールド（`GyakusasiOrderType`など）がリクエストに不足していることが根本原因であると特定。`order_usecase_impl.go`でこれらのフィールドにテストコードと同じデフォルト値を設定したところ、**API呼び出しが成功し、HTTPステータス `201` と注文IDが返却されることを確認した。**

#### 次回のアクションプラン (2025-12-09 以降)

`POST /order` APIの基本的なE2Eテストが成功したため、次の実装フェーズに進む。

1.  **リポジトリ層の実装:**
    *   **対象:** `internal/infrastructure/repository`
    *   **内容:** 現在ダミー実装となっている`OrderRepository`を、PostgreSQLと`gorm`を使用して永続化する実装に置き換える。データベース接続のセットアップも含む。
    *   **目的:** 注文情報をデータベースに保存し、システムの永続化基盤を構築する。

2.  **WebSocket接続テストの再開:**
    *   **対象:** `TestEventClient_ConnectReadMessagesWithDemoAPI`
    *   **内容:** `websocket: bad handshake`エラーのデバッグを、平日の取引時間中に再度実施する。
    *   **目的:** リアルタイムの株価・約定情報を受信する機能を確立する。

3.  **Goaサービスの追加開発:**
    *   **対象:** `Balance`, `Position`などの未実装サービス
    *   **内容:** `SYSTEM_DESIGN_MEMO.md`に記載した「Goaサービス実装の標準手順」に従い、他のサービスの開発に着手する。
    *   **目的:** アプリケーションのコア機能を拡充する。


まずユースケースがセカンドパスワードを扱う必要があるのか？行き当たりばったりで浅はかな解決に走り、アーキテクチャの基本から外れていないか

非常に鋭いご指摘です。そして、その疑問はアーキテクチャを考える上で極めて重要です。

  結論から言うと、理想的な設計では、ユースケースがパスワードのようなインフラ層の詳細を直接扱うべきでは
  ありません。

  ご指摘の通り、UseCaseはアプリケーションのビジネスルールを記述する層であり、「パスワードを使ってAPIリ
  クエストを組み立てる」という処理は、本来インフラ層が担当すべき責務です。

  では、なぜ今回はパスワードを渡す形になったのか

  これは、APIを早期に動作させることを優先し、変更範囲を最小限に抑えた結果、アーキテクチャ的な理想から
  は少し妥協した形になっているためです。

  現状の設計では、UseCaseが「証券会社APIのリクエストDTO（ReqNewOrder）を組み立てる」という責務を持って
  います。そして、そのリクエストの一部としてSecondPasswordが必須であるため、UseCaseはどうしてもパスワ
  ードを知る必要がありました。

  より良い設計（今後のリファクタリング案）

  本来あるべき姿は、OrderClientインターフェースの抽象度を上げ、パスワードを完全にインフラ層に隠蔽する
  ことです。

  例えば、OrderClientのNewOrderメソッドが、UseCaseからOrderParamsのようなビジネス的な情報だけを受け取
  ります。
   1 // in OrderClient interface
   2 NewOrder(ctx context.Context, params app.OrderParams) (*response.ResNewOrder, error)
  そして、OrderClientの実装（order_client_impl.go）の中で、paramsと、設定ファイルから取得したSecondPas
  swordを組み合わせて、実際のAPIリクエスト（ReqNewOrder）を組み立てます。

  こうすれば、UseCaseはパスワードの存在を一切知ることなく、自身のビジネスロジックに集中できます。

  結論

  あなたの「ユースケースがパスワードを扱うべきか」という問いは正しく、現在の実装はその点で改善の余地が
  あります。
  今回の修正は、まずエラーを解消するための現実的な一歩と捉えていただければ幸いです。将来的には、この部
  分をリファクタリングして、よりクリーンな関心の分離を目指すべきだと考えています。

---

### 開発進捗 (2025-12-09)

#### アーキテクチャ改善計画：責務の分離リファクタリング

- **課題の特定**: `POST /order` APIのデバッグ過程で、`OrderUseCase` がインフラ層の詳細である `SecondPassword` を扱っている問題が明らかになった。これは「関心の分離」の原則に反しており、技術的負債となる。
- **標準手順の策定**: このようなレイヤー間の責務移動を伴うリファクタリングを安全かつ一貫して行うため、新たに `planning/REFACTORING_PROCEDURE.md` を作成した。

### 開発進捗 (2025-12-11)

#### `OrderClient` 関連テストの修正
- **課題**: `SecondPassword` の責務を `UseCase` 層から `Infrastructure` 層へ移譲するリファクタリング (`2025-12-09` 実施) の影響で、`OrderClient` を利用している複数のテスト (`cancelorder`, `cancelorderall`, `correctorder`) でコンパイルエラーが発生していた。
- **修正**:
    1. `NewOrder` メソッドの呼び出し部分を、新しい `client.NewOrderParams` 構造体を使うように修正し、すべてのコンパイルエラーを解消。
    2. `order_client_impl_cancelorder_test.go` で発生していた実行時エラー（APIエラーコード `13001`, `11121`）を調査。原因が逆指値注文のパラメータにあると特定。
    3. ユーザーの指示に基づき、テストの意図（特定のリクエストを生成すること）を維持するため、`NewOrderParams` の値は元のテストコードの値を保持するように最終調整。これにより、テストはコンパイル可能だが、APIの仕様により実行時には失敗する可能性がある状態となった。
- **結論**: `OrderClient` に関連するテストは、リファクタリング後のインターフェースに準拠した形に修正され、コンパイル可能な状態に復旧した。

#### 次回のアクションプラン (2025-12-12 以降)

1.  **リポジトリ層の実装 (継続)**
    *   **対象:** `internal/infrastructure/repository`
    *   **内容:** `OrderRepository` をPostgreSQLで永続化する。

2.  **WebSocket接続テストの再開 (継続)**
    *   **対象:** `TestEventClient_ConnectReadMessagesWithDemoAPI`
    *   **内容:** 平日の取引時間中に `websocket: bad handshake` エラーのデバッグを再開する。