# エージェント要件定義

## 0. 前提となるシステム構成とツール群

エージェントは、独立した複数の「ツール」を適切なタイミングで利用し、全体のワークフローを指揮する「司令塔」として機能する。

### 0.1. ツール群の定義

| ツール名 | 実装言語 | 主な役割 |
| :--- | :--- | :--- |
| **モデルメーカー** | Python | **[重い処理]** 長期データから特徴量を生成し、機械学習モデルを構築・更新する。 |
| **シグナルメーカー** | Python | **[軽い処理]** 学習済みモデルを使い、その日の**売買シグナル**を生成し、以下のバイナリフォーマットでファイルに出力する。<br>- **レコード**: 銘柄コード(`uint16`) + 売買区分(`uint8`) の3バイト構成。<br>- **売買区分**: `0x01`=BUY, `0x02`=SELL。 |
| **パラメータオプティマイザー** | Go | バックテストを行い、**最適な利確・損切りパラメータ**を計算・提供する。 |
| **トレードサービス** | Go (Goa) | 証券会社APIと通信し、**注文実行**や**DBへの状態永続化**を行う。 |

### 0.2. エージェントのワークフロー

エージェントは、これらのツールを以下のように利用して取引を実行する。

1.  **準備フェーズ (取引開始前など)**:
    -   **パラメータ設定**: **パラメータオプティマイザー**が算出した最適パラメータを `config.yaml` から読み込む。
    -   **シグナル生成**: **シグナルメーカー**を実行し、その日の売買シグナルが記述された「シグナルファイル」を取得する。

2.  **実行フェーズ (取引時間中など)**:
    -   **意思決定**: 取得した「シグナルファイル」と「最適パラメータ」に基づき、具体的な注文内容（銘柄、数量、注文方法など）を決定する。
    -   **注文実行**: **トレードサービス**を呼び出し、意思決定した内容で発注を指示する。


本ドキュメントは、株式自動取引システムの「エージェント(Agent)」コンポーネントの要件を定義する。

## 1. ユースケースストーリー: エージェントの一日

「状態管理」が実際の取引でどのように機能するのかを、具体的なストーリー形式で以下に示す。

---
### **とあるエージェントの一日**

#### **【9:00前】 起動と準備**
1.  エージェントは起動すると、まず自身の状態を**「準備中」**にします。
2.  次に、**状態管理**の一環として、「トレードサービス」を通じて証券会社に現在の正確な**口座情報**を問い合わせます。
    *   「現在の現金残高は1,000万円か…」
    *   「前日から持ち越しているA社の株が100株あるな…」
3.  エージェントはこれらの情報を自身の「記憶（状態）」にしっかりと記録します。
4.  準備が完了すると、自身の状態を**「監視中」**に変え、取引開始を待ちます。

#### **【9:30】 シグナル発生**
1.  エージェントは、定期巡回（tick）で「シグナルファイル」をチェックし、「**B社の株を買い**」というシグナルを見つけます。
2.  ここで**意思決定ロジック**が働きます。
    *   **（状態確認①）**：「B社の株は、今すでに保有しているだろうか？」
        *   → 自身の「記憶（状態）」を確認。「いや、持っていないな。よし、買ってOKだ。」
    *   **（状態確認②）**：「B社の株を買うお金は足りるだろうか？」
        *   → 起動時に記憶した現金残高と現在の株価を比較。「うん、十分足りるな。」
3.  全ての確認が取れたため、エージェントは「トレードサービス」に**B株の買い注文**を指示します。
4.  発注後、すぐに自身の状態を更新します。「現在、B株の買い注文が**発注中**」と記憶します。

#### **【10:00】 約定の確認**
1.  エージェントは「トレードサービス」を通じて、「B株の買い注文が約定した」ことを知ります。
2.  すぐさま自身の状態を更新します。
    *   「発注中リスト」からB株の注文を削除。
    *   「**保有ポジションリスト**」に「B株 100株（取得単価 XXX円）」を追加。
    *   「現金残高」から買付代金を差し引く。
    *   → これでエージェントは、「自分がいま何を持っているか」を正確に把握できました。

#### **【11:00】 ２つ目のシグナル**
1.  エージェントは、巡回中に再び「**B社の株を買い**」というシグナルを見つけました。
2.  **意思決定ロジック**が働きます。
    *   **（状態確認）**：「B社の株は、今すでに保有しているだろうか？」
        *   → 自身の「記憶（状態）」を確認。「おっと、さっき買ったばかりだ。重複して買うのはリスクが高いから、このシグナルは**見送ろう**。」
    *   → **状態管理機能がなければ、ここで不要な重複買いをしてしまっていました。**

#### **【14:30】 予期せぬ急落と自動損切り**
1.  この日のシグナルはもうありません。
2.  しかし、エージェントは常に自身の「**保有ポジション**」を監視しています。B株の株価が下落し、`config.yaml`で決められた「損切り率（-2%）」に達してしまいました。
3.  **意思決定ロジック**（リスク管理部分）が作動し、「保有しているB株を全て**損切りのために売る**」と即座に判断。
4.  エージェントは「トレードサービス」に売り注文を出し、損失の拡大を防ぎました。

---

このように、エージェントが**過去の行動や現在の状況を記憶（状態管理）**することで、単純にシグナルに従うだけでなく、より安全で賢明な取引判断が可能になります。


## 1. 概要

エージェントはシステム全体の「頭脳」として、以下の役割を担う。

-   **役割**: 主体的な意思決定を行う中央司令塔。
-   **機能**: 取引戦略のメインループとして、Go APIラッパー（データ取得/注文）とPythonサービス（シグナル問合せ）を呼び出し、全体のワークフローを指揮する。

## 2. アーキテクチャ方針

-   **共通プラットフォーム + 戦略モジュール**:
    -   異なる取引戦略（デイトレード、スイングトレード等）で共通して利用可能な「プラットフォーム」としてのコア機能を実装する。
    -   個別の取引戦略は、このプラットフォーム上で動作する「戦略モジュール」として実装し、交換可能（pluggable）な設計を目指す。
    -   初期実装では、共通プラットフォームの構築と、「スイングトレード」戦略モジュールの実装を目標とする。シグナル生成については、当面Pythonサービスとのリアルタイム連携ではなく、外部から提供されるシグナルファイルを読み込む方式を採用する。

## 3. 機能要件 (共通プラットフォーム)

### 3.1. 設定管理 (Configuration)
-   **要件**:
    -   取引戦略のパラメータ（取引対象銘柄リスト、ロットサイズ、利確/損切り幅など）を外部ファイル（例: `config.yaml`）から読み込めること。
    -   APIのエンドポイントや認証情報、ログレベルなどのシステム設定も同ファイルで管理できること。
-   **目的**: コードを変更せずにエージェントの振る舞いを調整できるようにするため。

### 3.2. 状態管理 (State Management)
-   **要件**:
    -   現在のポジション（保有銘柄、数量、平均取得単価）をメモリ上で管理できること。
    -   発注中の注文情報（未約定注文）を管理できること。
    -   口座の資金余力（現金、買付可能額）を管理できること。
    -   エージェント自身の内部状態（例: `初期化中`, `待機中`, `シグナル待ち`, `発注中`, `エラー停止`）を管理できること。
-   **目的**: 意思決定の基礎となる、エージェントが置かれている状況を正確に把握するため。

### 3.3. 実行ループ (Execution Loop)
-   **要件**:
    -   市場の取引時間に合わせて、定期的にワークフローを実行するスケジューラを持つこと。
    -   実行間隔は設定ファイルで変更可能であること。
    -   ワークフロー（シグナルファイル読み込み→意思決定→発注）を制御するメインループを実装すること。
-   **目的**: 取引戦略を自律的かつ継続的に実行するため。

### 3.4. 意思決定ロジック (Decision Logic)
-   **要件**:
    -   戦略モジュール（シグナルファイル）から渡されたシグナル（銘柄コード、売買区分）と、現在の状態（ポジション有無、資金余力、市場状況など）を組み合わせて、最終的な行動を決定するコアロジックを持つこと。
    -   **シグナル解釈と注文方法の決定**:
        -   シグナルファイルから受け取った「銘柄コード」と「売買区分（BUY/SELL）」に基づき、現在の市場状況やリスク許容度に応じて、最適な「注文種別（MARKET/LIMIT）」および「数量」を決定する。
        -   指値注文の場合、適切な指値価格を算出する。
    -   **リスク管理（自動利確・損切り）**:
        -   保有ポジションに対し、設定ファイル（`config.yaml`）で定義された利確率（`profit_take_rate`）と損切り率（`stop_loss_rate`）に基づき、自動的に利確・損切り注文を出す判断を行う。
        -   利確・損切り判断は、戦略モジュールからの明確な手仕舞いシグナルがない場合でも実行される。
    -   戦略モジュールからの指示と、リスク管理ロジックの間で競合が発生した場合の優先順位付けロジックを持つこと。
-   **目的**: 戦略モジュールの判断を、実際の取引アクションに変換し、エージェントが自律的なリスク管理を伴う取引判断を行えるようにするため。

### 3.5. API連携 (API Integration)
-   **要件**:
    -   Goaで定義された各APIクライアント（`BalanceClient`, `OrderClient`, `PriceInfoClient`など）を呼び出せること。
    -   取引シグナルが記述された外部ファイル（`.bin`形式などを想定）をパース（解析）して、取引指示を読み込めること。
-   **目的**: 外部コンポーネントと連携し、ワークフローを実行するため。

### 3.6. エラーハンドリングと耐障害性 (Error Handling & Resilience)
-   **要件**:
    -   API呼び出しの失敗（ネットワークエラー、APIエラーレスポンス）に対して、設定可能なリトライ処理を行えること。
    -   セッション切れを検知した場合、再ログインを試みること（本番環境の電話認証制約を考慮し、失敗時は管理者に通知する）。
    -   予期せぬエラーが発生した場合、安全に停止（例: 全ての未約定注文をキャンセルし、エージェントを停止）するフェールセーフ機構を持つこと。
-   **目的**: システムの安定稼働と、想定外の事態による損失を防ぐため。

### 3.7. ロギング (Logging)
-   **要件**:
    -   エージェントの全ての主要な決定と行動（シグナル受信、発注、エラー、状態遷移など）を、構造化ログ（JSON形式など）として記録できること。
    -   ログレベル（DEBUG, INFO, WARN, ERROR）を設定ファイルで変更できること。
-   **目的**: 稼働状況の監視と、問題発生時の原因究明を容易にするため。

## 4. 未解決の課題
-   （ここに議論で出てきた課題などを追記していく）
