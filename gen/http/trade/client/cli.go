// Code generated by goa v3.23.1, DO NOT EDIT.
//
// trade HTTP client CLI support package
//
// Command:
// $ goa gen stock-bot/design

package client

import (
	"encoding/json"
	"fmt"
	trade "stock-bot/gen/trade"
	"strconv"

	goa "goa.design/goa/v3/pkg"
)

// BuildGetPriceHistoryPayload builds the payload for the trade
// get_price_history endpoint from CLI flags.
func BuildGetPriceHistoryPayload(tradeGetPriceHistorySymbol string, tradeGetPriceHistoryDays string) (*trade.GetPriceHistoryPayload, error) {
	var err error
	var symbol string
	{
		symbol = tradeGetPriceHistorySymbol
	}
	var days uint
	{
		if tradeGetPriceHistoryDays != "" {
			var v uint64
			v, err = strconv.ParseUint(tradeGetPriceHistoryDays, 10, strconv.IntSize)
			days = uint(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for days, must be UINT")
			}
		}
	}
	v := &trade.GetPriceHistoryPayload{}
	v.Symbol = symbol
	v.Days = days

	return v, nil
}

// BuildPlaceOrderPayload builds the payload for the trade place_order endpoint
// from CLI flags.
func BuildPlaceOrderPayload(tradePlaceOrderBody string) (*trade.PlaceOrderPayload, error) {
	var err error
	var body PlaceOrderRequestBody
	{
		err = json.Unmarshal([]byte(tradePlaceOrderBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"order_type\": \"MARKET\",\n      \"position_account_type\": \"MARGIN_REPAY\",\n      \"price\": 0.035352781886726636,\n      \"quantity\": 11753193439472030627,\n      \"symbol\": \"Ab voluptates accusantium ut.\",\n      \"trade_type\": \"BUY\",\n      \"trigger_price\": 0.23317448032527996\n   }'")
		}
		if !(body.TradeType == "BUY" || body.TradeType == "SELL") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.trade_type", body.TradeType, []any{"BUY", "SELL"}))
		}
		if !(body.OrderType == "MARKET" || body.OrderType == "LIMIT" || body.OrderType == "STOP" || body.OrderType == "STOP_LIMIT") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.order_type", body.OrderType, []any{"MARKET", "LIMIT", "STOP", "STOP_LIMIT"}))
		}
		if !(body.PositionAccountType == "CASH" || body.PositionAccountType == "MARGIN_NEW" || body.PositionAccountType == "MARGIN_REPAY") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.position_account_type", body.PositionAccountType, []any{"CASH", "MARGIN_NEW", "MARGIN_REPAY"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &trade.PlaceOrderPayload{
		Symbol:              body.Symbol,
		TradeType:           body.TradeType,
		OrderType:           body.OrderType,
		Quantity:            body.Quantity,
		Price:               body.Price,
		TriggerPrice:        body.TriggerPrice,
		PositionAccountType: body.PositionAccountType,
	}
	{
		var zero float64
		if v.Price == zero {
			v.Price = 0
		}
	}
	{
		var zero float64
		if v.TriggerPrice == zero {
			v.TriggerPrice = 0
		}
	}
	{
		var zero string
		if v.PositionAccountType == zero {
			v.PositionAccountType = "CASH"
		}
	}

	return v, nil
}

// BuildCancelOrderPayload builds the payload for the trade cancel_order
// endpoint from CLI flags.
func BuildCancelOrderPayload(tradeCancelOrderOrderID string) (*trade.CancelOrderPayload, error) {
	var orderID string
	{
		orderID = tradeCancelOrderOrderID
	}
	v := &trade.CancelOrderPayload{}
	v.OrderID = orderID

	return v, nil
}

// BuildCorrectOrderPayload builds the payload for the trade correct_order
// endpoint from CLI flags.
func BuildCorrectOrderPayload(tradeCorrectOrderBody string, tradeCorrectOrderOrderID string) (*trade.CorrectOrderPayload, error) {
	var err error
	var body CorrectOrderRequestBody
	{
		err = json.Unmarshal([]byte(tradeCorrectOrderBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"price\": 0.21831992093893263,\n      \"quantity\": 3060878601666675377\n   }'")
		}
	}
	var orderID string
	{
		orderID = tradeCorrectOrderOrderID
	}
	v := &trade.CorrectOrderPayload{
		Price:    body.Price,
		Quantity: body.Quantity,
	}
	v.OrderID = orderID

	return v, nil
}

// BuildValidateSymbolPayload builds the payload for the trade validate_symbol
// endpoint from CLI flags.
func BuildValidateSymbolPayload(tradeValidateSymbolSymbol string) (*trade.ValidateSymbolPayload, error) {
	var symbol string
	{
		symbol = tradeValidateSymbolSymbol
	}
	v := &trade.ValidateSymbolPayload{}
	v.Symbol = symbol

	return v, nil
}

// BuildGetOrderHistoryPayload builds the payload for the trade
// get_order_history endpoint from CLI flags.
func BuildGetOrderHistoryPayload(tradeGetOrderHistoryStatus string, tradeGetOrderHistorySymbol string, tradeGetOrderHistoryLimit string) (*trade.GetOrderHistoryPayload, error) {
	var err error
	var status *string
	{
		if tradeGetOrderHistoryStatus != "" {
			status = &tradeGetOrderHistoryStatus
			if !(*status == "NEW" || *status == "PARTIALLY_FILLED" || *status == "FILLED" || *status == "CANCELLED" || *status == "REJECTED") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", *status, []any{"NEW", "PARTIALLY_FILLED", "FILLED", "CANCELLED", "REJECTED"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var symbol *string
	{
		if tradeGetOrderHistorySymbol != "" {
			symbol = &tradeGetOrderHistorySymbol
		}
	}
	var limit uint
	{
		if tradeGetOrderHistoryLimit != "" {
			var v uint64
			v, err = strconv.ParseUint(tradeGetOrderHistoryLimit, 10, strconv.IntSize)
			limit = uint(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be UINT")
			}
		}
	}
	v := &trade.GetOrderHistoryPayload{}
	v.Status = status
	v.Symbol = symbol
	v.Limit = limit

	return v, nil
}
