// Code generated by goa v3.23.1, DO NOT EDIT.
//
// trade HTTP client encoders and decoders
//
// Command:
// $ goa gen stock-bot/design

package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	trade "stock-bot/gen/trade"

	goahttp "goa.design/goa/v3/http"
)

// BuildGetSessionRequest instantiates a HTTP request object with method and
// path set to call the "trade" service "get_session" endpoint
func (c *Client) BuildGetSessionRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSessionTradePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("trade", "get_session", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetSessionResponse returns a decoder for responses returned by the
// trade get_session endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetSessionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSessionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("trade", "get_session", err)
			}
			err = ValidateGetSessionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("trade", "get_session", err)
			}
			res := NewGetSessionResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("trade", "get_session", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPositionsRequest instantiates a HTTP request object with method and
// path set to call the "trade" service "get_positions" endpoint
func (c *Client) BuildGetPositionsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPositionsTradePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("trade", "get_positions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetPositionsResponse returns a decoder for responses returned by the
// trade get_positions endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetPositionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPositionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("trade", "get_positions", err)
			}
			err = ValidateGetPositionsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("trade", "get_positions", err)
			}
			res := NewGetPositionsResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("trade", "get_positions", resp.StatusCode, string(body))
		}
	}
}

// BuildGetOrdersRequest instantiates a HTTP request object with method and
// path set to call the "trade" service "get_orders" endpoint
func (c *Client) BuildGetOrdersRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetOrdersTradePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("trade", "get_orders", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetOrdersResponse returns a decoder for responses returned by the
// trade get_orders endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetOrdersResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetOrdersResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("trade", "get_orders", err)
			}
			err = ValidateGetOrdersResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("trade", "get_orders", err)
			}
			res := NewGetOrdersResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("trade", "get_orders", resp.StatusCode, string(body))
		}
	}
}

// BuildGetBalanceRequest instantiates a HTTP request object with method and
// path set to call the "trade" service "get_balance" endpoint
func (c *Client) BuildGetBalanceRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetBalanceTradePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("trade", "get_balance", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetBalanceResponse returns a decoder for responses returned by the
// trade get_balance endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetBalanceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetBalanceResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("trade", "get_balance", err)
			}
			err = ValidateGetBalanceResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("trade", "get_balance", err)
			}
			res := NewGetBalanceTradeBalanceResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("trade", "get_balance", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPriceHistoryRequest instantiates a HTTP request object with method
// and path set to call the "trade" service "get_price_history" endpoint
func (c *Client) BuildGetPriceHistoryRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		symbol string
	)
	{
		p, ok := v.(*trade.GetPriceHistoryPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("trade", "get_price_history", "*trade.GetPriceHistoryPayload", v)
		}
		symbol = p.Symbol
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPriceHistoryTradePath(symbol)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("trade", "get_price_history", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPriceHistoryRequest returns an encoder for requests sent to the
// trade get_price_history server.
func EncodeGetPriceHistoryRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*trade.GetPriceHistoryPayload)
		if !ok {
			return goahttp.ErrInvalidType("trade", "get_price_history", "*trade.GetPriceHistoryPayload", v)
		}
		values := req.URL.Query()
		values.Add("days", fmt.Sprintf("%v", p.Days))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPriceHistoryResponse returns a decoder for responses returned by
// the trade get_price_history endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeGetPriceHistoryResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPriceHistoryResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("trade", "get_price_history", err)
			}
			err = ValidateGetPriceHistoryResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("trade", "get_price_history", err)
			}
			res := NewGetPriceHistoryResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("trade", "get_price_history", resp.StatusCode, string(body))
		}
	}
}

// BuildPlaceOrderRequest instantiates a HTTP request object with method and
// path set to call the "trade" service "place_order" endpoint
func (c *Client) BuildPlaceOrderRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PlaceOrderTradePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("trade", "place_order", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePlaceOrderRequest returns an encoder for requests sent to the trade
// place_order server.
func EncodePlaceOrderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*trade.PlaceOrderPayload)
		if !ok {
			return goahttp.ErrInvalidType("trade", "place_order", "*trade.PlaceOrderPayload", v)
		}
		body := NewPlaceOrderRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("trade", "place_order", err)
		}
		return nil
	}
}

// DecodePlaceOrderResponse returns a decoder for responses returned by the
// trade place_order endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodePlaceOrderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body PlaceOrderResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("trade", "place_order", err)
			}
			err = ValidatePlaceOrderResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("trade", "place_order", err)
			}
			res := NewPlaceOrderTradeOrderResultCreated(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("trade", "place_order", resp.StatusCode, string(body))
		}
	}
}

// BuildCancelOrderRequest instantiates a HTTP request object with method and
// path set to call the "trade" service "cancel_order" endpoint
func (c *Client) BuildCancelOrderRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		orderID string
	)
	{
		p, ok := v.(*trade.CancelOrderPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("trade", "cancel_order", "*trade.CancelOrderPayload", v)
		}
		orderID = p.OrderID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CancelOrderTradePath(orderID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("trade", "cancel_order", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeCancelOrderResponse returns a decoder for responses returned by the
// trade cancel_order endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeCancelOrderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("trade", "cancel_order", resp.StatusCode, string(body))
		}
	}
}

// unmarshalTradePositionResultResponseBodyToTradeTradePositionResult builds a
// value of type *trade.TradePositionResult from a value of type
// *TradePositionResultResponseBody.
func unmarshalTradePositionResultResponseBodyToTradeTradePositionResult(v *TradePositionResultResponseBody) *trade.TradePositionResult {
	res := &trade.TradePositionResult{
		Symbol:              *v.Symbol,
		PositionType:        *v.PositionType,
		PositionAccountType: *v.PositionAccountType,
		AveragePrice:        *v.AveragePrice,
		Quantity:            *v.Quantity,
	}

	return res
}

// unmarshalTradeOrderResultResponseBodyToTradeTradeOrderResult builds a value
// of type *trade.TradeOrderResult from a value of type
// *TradeOrderResultResponseBody.
func unmarshalTradeOrderResultResponseBodyToTradeTradeOrderResult(v *TradeOrderResultResponseBody) *trade.TradeOrderResult {
	res := &trade.TradeOrderResult{
		OrderID:             *v.OrderID,
		Symbol:              *v.Symbol,
		TradeType:           *v.TradeType,
		OrderType:           *v.OrderType,
		Quantity:            *v.Quantity,
		Price:               *v.Price,
		OrderStatus:         *v.OrderStatus,
		PositionAccountType: v.PositionAccountType,
	}

	return res
}

// unmarshalTradePriceHistoryItemResponseBodyToTradeTradePriceHistoryItem
// builds a value of type *trade.TradePriceHistoryItem from a value of type
// *TradePriceHistoryItemResponseBody.
func unmarshalTradePriceHistoryItemResponseBodyToTradeTradePriceHistoryItem(v *TradePriceHistoryItemResponseBody) *trade.TradePriceHistoryItem {
	res := &trade.TradePriceHistoryItem{
		Date:   *v.Date,
		Open:   *v.Open,
		High:   *v.High,
		Low:    *v.Low,
		Close:  *v.Close,
		Volume: *v.Volume,
	}

	return res
}
